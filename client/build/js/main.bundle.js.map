{"version":3,"file":"main.bundle.js","mappings":";;;;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACZ;AACP;AACA;AACA;AACA;AACA,0BAA0B,YAAY,IAAI,YAAY;AACtD;AACA,0BAA0B,YAAY,IAAI,YAAY;AACtD;AACA,0BAA0B,YAAY,IAAI,YAAY;AACtD;AACA,0BAA0B,YAAY,IAAI,YAAY;AACtD;AACA;AACA,0BAA0B,YAAY,IAAI,YAAY,IAAI,YAAY,IAAI,YAAY;AACtF;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,8BAA8B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7BW;AAC1C;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACO,YAAY,uDAAY;;;;;;;;;;;;;;;;;;AC3BW;AACH;AACC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAM,aAAa,qCAAqC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qCAAqC,YAAY,GAAG;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAM;AAC5B,iCAAiC,sDAAU,2EAA2E,sDAAU,4EAA4E,sDAAU,eAAe,sDAAU;AAC/O;AACA;AACA;;;;;;;;;;;;;;;;;;ACvGmC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAI;AAC5B,wBAAwB,+CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACb;AACP;AACA;;;;;;;;;;;;;;;;;ACjCyC;AACE;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mDAAU,SAAS,KAAK,wCAAG,OAAO;AACxF;AACA;AACA;AACA;AACA,sDAAsD,mDAAU,SAAS,KAAK,wCAAG,QAAQ;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mDAAU,SAAS,KAAK,wCAAG,KAAK;AACtF;AACA;AACA;AACA;AACA,sDAAsD,mDAAU,SAAS,KAAK,wCAAG,OAAO;AACxF;AACA;AACA;AACA;AACA;AACA,kEAAkE,oBAAoB,IAAI,YAAY;AACtG;AACA;AACA;AACA;AACA,kEAAkE,oBAAoB,IAAI,YAAY;AACtG;AACA;AACA;AACA;AACA,kEAAkE,oBAAoB,IAAI,YAAY;AACtG;AACA;AACA;AACA;AACA,kEAAkE,oBAAoB,IAAI,YAAY;AACtG;AACA;AACA;AACA,uCAAuC,sCAAsC,IAAI;AACjF;AACA;AACA;AACA,wBAAwB,yCAAI;AAC5B;AACA;AACA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO,IAAI,QAAQ,YAAY,OAAO,IAAI,OAAO;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7I4G;AAC9D;AACJ;AACQ;AAChB;AAClC;AACO,qBAAqB,2CAAM;AAClC;AACA;AACA,8BAA8B,qDAAa,GAAG,2CAAG;AACjD;AACA;AACA,iBAAiB,sDAAU;AAC3B,iBAAiB,sDAAU;AAC3B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD,mBAAmB,qDAAa;AAChC,4BAA4B,cAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wEAAwE,+CAAQ;AAChF,uCAAuC,iDAAS;AAChD,wCAAwC,kDAAU;AAClD,qCAAqC,+CAAO;AAC5C,uCAAuC,iDAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,0DAAU;AACxE;AACA;AACA;AACA;AACA,cAAc,mDAAQ,aAAa,sCAAsC;AACzE;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC3EqG;AAC1D;AACU;AACd;AACG;AACF;AACC;AACT;AACU;AACd;AACS;AAC9B;AACP;AACA;AACA;AACA;AACA,4BAA4B,+CAAQ;AACpC;AACA;AACA,mEAAmE,eAAe;AAClF;AACA;AACA;AACA;AACA,wBAAwB,mDAAY;AACpC,QAAQ,+CAAM;AACd;AACA;AACA;AACA,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2CAAM;AACtD;AACA;AACA,2CAA2C,2CAAM,eAAe,2CAAM;AACtE;AACA;AACA;AACA,0BAA0B,2CAAM;AAChC,0BAA0B,yCAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAS;AACjC,2CAA2C,iDAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oDAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAa;AAClD,sCAAsC,sDAAc;AACpD;AACA;AACA,+BAA+B,qDAAa;AAC5C,sDAAsD,qBAAqB;AAC3E;AACA;AACA,qCAAqC,YAAY;AACjD,sCAAsC,aAAa;AACnD;AACA,QAAQ,mDAAQ;AAChB;AACA,0DAA0D,YAAY;AACtE,2DAA2D,aAAa;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2CAAM;AAClB,YAAY,+CAAK;AACjB,YAAY,kDAAM;AAClB,YAAY,mDAAU;AACtB;AACA,QAAQ,qCAAG;AACX;AACA;;;;;;;;;;;;;;;;;;;;;;;AC1J4C;AACL;AACG;AACH;AACE;AACI;AACI;AACZ;AACrC;AACO;AACP;AACA;AACA,0BAA0B,gDAAW;AACrC,yBAAyB,8CAAK;AAC9B,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAM;AAC5B;AACA;AACA,yBAAyB,8CAAK;AAC9B,8BAA8B,mDAAU;AACxC,eAAe,oDAAY;AAC3B,eAAe,oDAAY;AAC3B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,4BAA4B,iBAAiB;AAC7C,0DAA0D,MAAM,IAAI,cAAc;AAClF;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM,EAAE,sDAAQ,SAAS,kBAAkB;AAC9F;AACA;AACA,mDAAmD,MAAM,EAAE,sDAAQ,eAAe,kBAAkB;AACpG;AACA;AACA,qDAAqD,MAAM,EAAE,0DAAU,SAAS,kBAAkB;AAClG,mDAAmD,MAAM,EAAE,sDAAQ,YAAY,kBAAkB;AACjG;AACA;AACA;AACA,qDAAqD,MAAM,EAAE,0DAAU,UAAU,kBAAkB;AACnG,mDAAmD,MAAM,EAAE,sDAAQ,YAAY,kBAAkB;AACjG;AACA;AACA,qDAAqD,MAAM,EAAE,0DAAU,aAAa,kBAAkB;AACtG,mDAAmD,MAAM,EAAE,sDAAQ,YAAY,kBAAkB;AACjG;AACA;AACA,kDAAkD,OAAO,KAAK,EAAE,IAAI,EAAE;AACtE;AACA;AACA;AACA;AACA,wCAAwC,iCAAiC;AACzE;AACA;AACA;AACA,2BAA2B,kDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9GuC;AACA;AAChC;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,0BAA0B,+CAAM,aAAa,oDAAoD;AACjG,8BAA8B,+CAAM;AACpC,8BAA8B,+CAAM,aAAa,kCAAkC;AACnF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrBA;AAC6B;AACqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uCAAI;AACnC;AACA;AACA;AACA,YAAY,+CAAM,eAAe,kDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;ACvBqC;AACH;AAClC;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AACtB,wBAAwB,kDAAS;AACxC;AACA;AACA;AACA,2BAA2B,YAAY;AACvC,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD,oCAAoC,gBAAgB;AACpD,mCAAmC,MAAM;AACzC;AACA;AACA;AACA,uCAAuC,aAAa;AACpD,uCAAuC,aAAa;AACpD;AACA;AACA,mCAAmC,MAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW,iDAAS,aAAa,iDAAS;AACtE;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA,yCAAyC;AACzC,kDAAkD,yBAAyB;AAC3E,oDAAoD,8BAA8B;AAClF,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA,yCAAyC;AACzC,kDAAkD,yBAAyB;AAC3E,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClH4C;AACH;AAClC;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA,0BAA0B,YAAY;AACtC,yBAAyB,YAAY;AACrC,6BAA6B,YAAY;AACzC;AACO,0BAA0B,kDAAS;AAC1C;AACA;AACA,4BAA4B,WAAW,iDAAS,aAAa,iDAAS;AACtE;AACA;AACA;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA;;;;;;;;;;;;;;;;;ACzB0D;AAChB;AAC1C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,YAAY;AACpE;AACA;AACA;AACA,SAAS;AACT,qDAAqD,iDAAS;AAC9D,qDAAqD,iDAAS;AAC9D,qDAAqD,iDAAS;AAC9D,qDAAqD,iDAAS;AAC9D,+BAA+B,eAAe;AAC9C,mCAAmC,eAAe;AAClD,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA,kDAAkD,oDAAY,cAAc,oDAAY,EAAE,oDAAY,EAAE,oDAAY;AACpH;AACA,QAAQ,iDAAS,MAAM,iDAAS;AAChC;AACA,+BAA+B,iCAAiC;AAChE;AACA,+BAA+B,oDAAY;AAC3C,6BAA6B,iDAAS;AACtC,kDAAkD,oDAAY,8CAA8C,oDAAY;AACxH;AACA;AACA;AACA,uBAAuB,mBAAmB,IAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI,IAAI,IAAI;AAC/D;AACA;AACA;AACA,8BAA8B,mBAAmB,IAAI;AACrD;AACA,gCAAgC,iDAAS;AACzC,gCAAgC,iDAAS;AACzC,SAAS,UAAU,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAS;AACzC,gCAAgC,iDAAS;AACzC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjI4C;AACF;AACS;AACM;AACzD;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACO;AACP;AACA,6BAA6B,kDAAS;AACtC,+BAA+B,sDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAS,IAAI,iDAAS;AAC3C,qBAAqB,iDAAS,IAAI,iDAAS;AAC3C;AACA;AACA;AACA,mCAAmC,oBAAoB,iDAAS,uBAAuB,iDAAS,GAAG;AACnG;AACA;AACA,cAAc,+CAAM,aAAa,iCAAiC;AAClE;AACA;AACA;AACA,wBAAwB,iDAAQ;AAChC;AACA;AACA;AACA,0BAA0B,qDAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAS;AACzC,gCAAgC,iDAAS;AACzC,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,0EAA0E;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,EAAE,KAAK;AACvC,sBAAsB,SAAS,EAAE,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qEAAqE,KAAK;AAC1E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,MAAM;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,gBAAgB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA,qCAAqC,eAAe,EAAE,eAAe,EAAE,eAAe;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,qDAAqD,EAAE,GAAG,YAAY;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sBAAsB;AAC7B;AACA;AACA,CAAC,yDAAyD;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB;AAChC;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACvWO;AACP;AACA;AACA;AACO,qBAAqB,+BAA+B;AAC3D;AACA;AACA,oDAAoD,KAAK;AACzD;AACA;AACA;AACA;AACA,6BAA6B,KAAK,EAAE,KAAK,GAAG,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;AClCA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;ACzGuB;AACvB;AACP;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA,wDAAwD,KAAK;AAC7D;AACA;AACA;AACA;AACA,iCAAiC,KAAK,EAAE,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB,aAAa;AAClC;AACA,oDAAoD,KAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvLA;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,mBAAmB;AAChC;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACO;AACP,oBAAoB;AACpB,mBAAmB;AACnB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,GAAG;;;;;;;;;;;;;;;;;;;;;ACvGsC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,2BAA2B;AAC3B;AACA;AACA;AACA,2BAA2B;AAC3B,8BAA8B;AAC9B,0BAA0B;AAC1B,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B,0BAA0B;AAC1B,2BAA2B;AAC3B;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B;AACA,wBAAwB;AACxB,0BAA0B;AAC1B;AACA,qBAAqB;AACrB,0BAA0B;AAC1B;AACA,6BAA6B;AAC7B;AACA,2BAA2B;AAC3B,yBAAyB;AACzB;AACA,yBAAyB;AACzB,yBAAyB;AACzB,8BAA8B;AAC9B;AACA,yBAAyB;AACzB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,mBAAmB;AACnB,mBAAmB;AACnB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gCAAgC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gCAAgC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,wCAAwC;AACxC;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY,aAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0BAA0B;AAC3D,kCAAkC,0BAA0B;AAC5D,gCAAgC,WAAW;AAC3C,gCAAgC,0BAA0B;AAC1D,gCAAgC,2CAA2C;AAC3E,iCAAiC,2CAA2C;AAC5E,gCAAgC,uCAAuC;AACvE,iCAAiC,sCAAsC;AACvE,gCAAgC,iCAAiC;AACjE,mCAAmC,iBAAiB;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,2BAA2B,uBAAuB;AAClD,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA,KAAK;AACL,iCAAiC,kDAAkD;AACnF,+BAA+B,2CAA2C;AAC1E,+BAA+B,8BAA8B;AAC7D,+BAA+B,0BAA0B;AACzD,oCAAoC,2CAA2C;AAC/E,+BAA+B,8BAA8B;AAC7D,+BAA+B,0BAA0B;AACzD,8BAA8B;AAC9B;AACA;AACA,iCAAiC,iCAAiC;AAClE,kCAAkC,iCAAiC;AACnE,gCAAgC,WAAW;AAC3C,gCAAgC,iCAAiC;AACjE,gCAAgC,gDAAgD;AAChF,iCAAiC,gDAAgD;AACjF,gCAAgC,qCAAqC;AACrE,iCAAiC,kCAAkC;AACnE,gCAAgC,6BAA6B;AAC7D,mCAAmC,iBAAiB;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,2BAA2B,0BAA0B;AACrD,gCAAgC,sBAAsB;AACtD,mCAAmC,4DAA4D;AAC/F,iCAAiC,0DAA0D;AAC3F,+BAA+B,mDAAmD;AAClF,+BAA+B,4BAA4B;AAC3D,+BAA+B,4BAA4B;AAC3D,oCAAoC,+CAA+C;AACnF,+BAA+B,4BAA4B;AAC3D,+BAA+B,4BAA4B;AAC3D,8BAA8B;AAC9B;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD,kCAAkC,qBAAqB;AACvD,gCAAgC,mBAAmB;AACnD,gCAAgC,qBAAqB;AACrD,gCAAgC,WAAW;AAC3C,iCAAiC,WAAW;AAC5C,gCAAgC,+CAA+C;AAC/E,iCAAiC,oDAAoD;AACrF,gCAAgC,4BAA4B;AAC5D,mCAAmC,mBAAmB;AACtD,8BAA8B,kBAAkB;AAChD,gCAAgC,qBAAqB;AACrD,2BAA2B,mBAAmB;AAC9C,gCAAgC,yBAAyB;AACzD,mCAAmC,oCAAoC;AACvE,iCAAiC,4BAA4B;AAC7D,+BAA+B,oBAAoB;AACnD,+BAA+B,kDAAkD;AACjF,+BAA+B,4BAA4B;AAC3D,oCAAoC,+BAA+B;AACnE,+BAA+B,iCAAiC;AAChE,+BAA+B,4BAA4B;AAC3D,8BAA8B;AAC9B;AACA;AACA,iCAAiC,qBAAqB;AACtD,kCAAkC,qBAAqB;AACvD,gCAAgC,mBAAmB;AACnD,gCAAgC,qBAAqB;AACrD,gCAAgC,WAAW;AAC3C,iCAAiC,WAAW;AAC5C,gCAAgC,6CAA6C;AAC7E,iCAAiC,kDAAkD;AACnF,gCAAgC,4BAA4B;AAC5D,mCAAmC,mBAAmB;AACtD,8BAA8B,kBAAkB;AAChD,gCAAgC,qBAAqB;AACrD,2BAA2B,mBAAmB;AAC9C,gCAAgC,2BAA2B;AAC3D,mCAAmC,kDAAkD;AACrF,iCAAiC,4BAA4B;AAC7D,+BAA+B,oBAAoB;AACnD,+BAA+B,+BAA+B;AAC9D,+BAA+B,gCAAgC;AAC/D,oCAAoC,6BAA6B;AACjE,+BAA+B,+BAA+B;AAC9D,+BAA+B,gCAAgC;AAC/D,8BAA8B;AAC9B;AACA;AACA;AACA,iCAAiC,6CAA6C;AAC9E,kCAAkC,6CAA6C;AAC/E,gCAAgC,8CAA8C;AAC9E,gCAAgC,6CAA6C;AAC7E,gCAAgC,iCAAiC;AACjE,iCAAiC,iCAAiC;AAClE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,2BAA2B,wCAAwC;AACnE,gCAAgC,kDAAkD;AAClF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,oCAAoC,oDAAoD;AACxF;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;;;;;;;UCphCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNmC;AACnC;AACA,UAAU,4CAAI;AACd,qBAAqB,4CAAI;AACzB;AACA;AACA","sources":["webpack://ld55-client/./ts/common.ts","webpack://ld55-client/./ts/constants.ts","webpack://ld55-client/./ts/game/background.ts","webpack://ld55-client/./ts/game/camera.ts","webpack://ld55-client/./ts/game/entity/entity.ts","webpack://ld55-client/./ts/game/entity/player.ts","webpack://ld55-client/./ts/game/game.ts","webpack://ld55-client/./ts/game/level.ts","webpack://ld55-client/./ts/game/levels.ts","webpack://ld55-client/./ts/game/sfx.ts","webpack://ld55-client/./ts/game/tile/base-layer.ts","webpack://ld55-client/./ts/game/tile/object-layer.ts","webpack://ld55-client/./ts/game/tile/tile-layer.ts","webpack://ld55-client/./ts/game/tile/tiles.ts","webpack://ld55-client/./ts/lib/aseprite.ts","webpack://ld55-client/./ts/lib/images.ts","webpack://ld55-client/./ts/lib/keys.ts","webpack://ld55-client/./ts/lib/sounds.ts","webpack://ld55-client/./ts/lib/util.ts","webpack://ld55-client/./node_modules/jsfxr/riffwave.js","webpack://ld55-client/./node_modules/jsfxr/sfxr.js","webpack://ld55-client/webpack/bootstrap","webpack://ld55-client/webpack/runtime/define property getters","webpack://ld55-client/webpack/runtime/hasOwnProperty shorthand","webpack://ld55-client/webpack/runtime/make namespace object","webpack://ld55-client/./ts/main.ts"],"sourcesContent":["export var Dir;\n(function (Dir) {\n    Dir[Dir[\"Up\"] = 0] = \"Up\";\n    Dir[Dir[\"Down\"] = 1] = \"Down\";\n    Dir[Dir[\"Left\"] = 2] = \"Left\";\n    Dir[Dir[\"Right\"] = 3] = \"Right\";\n})(Dir || (Dir = {}));\nexport class Dirs {\n    static cornersInDirection(dir) {\n        // What we have to multiply the width and height by to get the corners of an rectangle if the given direction.\n        switch (dir) {\n            case Dir.Up:\n                return [{ x: 0, y: 0 }, { x: 1, y: 0 }];\n            case Dir.Down:\n                return [{ x: 0, y: 1 }, { x: 1, y: 1 }];\n            case Dir.Left:\n                return [{ x: 0, y: 0 }, { x: 0, y: 1 }];\n            case Dir.Right:\n                return [{ x: 1, y: 0 }, { x: 1, y: 1 }];\n            default:\n                // Every corner\n                return [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }];\n        }\n    }\n}\nexport var FacingDir;\n(function (FacingDir) {\n    FacingDir[FacingDir[\"Left\"] = 0] = \"Left\";\n    FacingDir[FacingDir[\"Right\"] = 1] = \"Right\";\n})(FacingDir || (FacingDir = {}));\n","import { seededRandom } from \"./lib/util\";\n// Multiple for the fixed-point physics.\nexport const PHYSICS_SCALE = 16;\nexport const FPS = 60;\nexport const TIME_STEP = 1 / FPS;\nexport const PIXEL_SCALE = 4;\nexport const GAME_WIDTH_PX = 200;\nexport const GAME_HEIGHT_PX = 150;\nexport const GAME_WIDTH = GAME_WIDTH_PX * PHYSICS_SCALE;\nexport const GAME_HEIGHT = GAME_HEIGHT_PX * PHYSICS_SCALE;\nexport const TILE_SIZE_PX = 16;\nexport const TILE_SIZE = TILE_SIZE_PX * PHYSICS_SCALE;\nexport const LEFT_KEYS = ['KeyA', 'ArrowLeft'];\nexport const RIGHT_KEYS = ['KeyD', 'ArrowRight'];\nexport const UP_KEYS = ['KeyW', 'ArrowUp'];\nexport const DOWN_KEYS = ['KeyS', 'ArrowDown'];\nexport const ACTION_KEYS = ['KeyE', 'Space'];\nexport const SELECT_KEYS = ['Space', 'Enter'];\nexport const TITLE_KEYS = ['Space', 'Enter'];\nexport const RESTART_KEYS = ['KeyR'];\nexport function physFromPx(x) {\n    return x * PHYSICS_SCALE;\n}\nexport function pxFromPhys(x) {\n    return Math.floor(x / PHYSICS_SCALE);\n}\n// Not really a constant :)\nexport const rng = seededRandom(\"hahahahahihihihi\");\n","import { physFromPx } from \"../constants\";\nimport { Images } from \"../lib/images\";\nimport { centerCanvas } from \"./camera\";\nconst BG_LAYERS = [\n    {\n        image: \"background\",\n        scale: 0.05,\n        offset: {\n            x: 0,\n            y: -20,\n        },\n    },\n    {\n        color: \"#c0cbdc\",\n    },\n];\nexport class Background {\n    constructor(level, offset) {\n        this.layers = [];\n        this.level = level;\n        this.offset = offset;\n        for (const layer of BG_LAYERS) {\n            if (\"image\" in layer) {\n                this.layers.push(new ImageLayer({\n                    background: this,\n                    image: layer.image,\n                    scale: layer.scale,\n                    offset: layer.offset,\n                }));\n            }\n            else {\n                this.layers.push(new FillLayer({\n                    color: layer.color,\n                }));\n            }\n        }\n    }\n    update(dt) {\n        for (const layer of this.layers) {\n            layer.update(dt);\n        }\n    }\n    render(context) {\n        for (const layer of this.layers) {\n            layer.render(context);\n        }\n    }\n    static async preload() {\n        const promises = [];\n        for (const layer of BG_LAYERS) {\n            if (\"image\" in layer) {\n                promises.push(Images.loadImage({ name: layer.image, path: \"sprites/\" }));\n            }\n        }\n        await Promise.all(promises);\n    }\n}\nclass FillLayer {\n    constructor({ color }) {\n        this.color = color;\n    }\n    update(dt) { }\n    render(context) {\n        // Clear transform\n        context.save();\n        context.resetTransform();\n        context.fillStyle = this.color;\n        context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n        context.restore();\n    }\n}\nclass ImageLayer {\n    constructor({ background, image, scale, offset = { x: 0, y: 0 }, }) {\n        this.animCount = 0;\n        this.image = \"\";\n        this.scale = 1;\n        this.background = background;\n        this.image = image;\n        this.scale = scale;\n        this.offset = offset;\n    }\n    update(dt) {\n        this.animCount += dt;\n    }\n    render(context) {\n        // TODO: Apply scale.\n        context.save();\n        context.resetTransform();\n        centerCanvas(context);\n        // This part of the code could be better so it's not reaching into the\n        // other parts of the code base as much. Probably requires refactoring\n        // of some camera stuff.\n        this.background.level.game.applyScale(context);\n        this.background.level.camera.applyTransform(context, this.scale);\n        // const isCloud = this.image.startsWith(\"bg-clouds\");\n        // let windOffset = 0;\n        // if (isCloud) {\n        //     windOffset = 30 * this.scale * this.animCount;\n        // }\n        const image = Images.images[this.image].image;\n        context.drawImage(image, physFromPx(this.offset.x - image.width / 2 + this.scale * this.background.offset.x), physFromPx(this.offset.y - image.height / 2 + this.scale * this.background.offset.y), physFromPx(image.width), physFromPx(image.height));\n        context.restore();\n    }\n}\n","import { lerp } from \"../lib/util\";\nexport class Camera {\n    constructor() {\n    }\n    update(dt) { }\n    applyTransform(context) { }\n}\nexport class FocusCamera extends Camera {\n    constructor() {\n        super();\n    }\n    update(dt) {\n        if (!this.target) {\n            return;\n        }\n        const targetPos = this.target();\n        if (!this.curPos) {\n            this.curPos = targetPos;\n            return;\n        }\n        const updateSmoothness = 1 - Math.exp(-3 * dt);\n        this.curPos.x = lerp(this.curPos.x, targetPos.x, updateSmoothness);\n        this.curPos.y = lerp(this.curPos.y, targetPos.y, updateSmoothness);\n    }\n    applyTransform(context, scale = 1) {\n        if (this.curPos) {\n            context.translate(Math.round(-scale * this.curPos.x), Math.round(-scale * this.curPos.y));\n        }\n    }\n}\nconst screenPos = { x: 0.5, y: 0.6 };\nexport function centerCanvas(context) {\n    context.translate(Math.round(context.canvas.width * screenPos.x), Math.round(context.canvas.height * screenPos.y));\n}\n","import { Dir, Dirs } from \"../../common\";\nimport { PhysicTile } from \"../tile/tiles\";\nexport class Entity {\n    constructor(level) {\n        this.x = 0;\n        this.y = 0;\n        this.w = 0;\n        this.h = 0;\n        this.dx = 0;\n        this.dy = 0;\n        this.animCount = 0;\n        this.canCollide = true;\n        this.done = false;\n        this.debugColor = '#ff00ff';\n        this.level = level;\n    }\n    update(dt) {\n        this.animCount += dt;\n        this.move(dt);\n    }\n    move(dt) {\n        this.moveX(dt);\n        this.moveY(dt);\n    }\n    moveX(dt) {\n        this.x += this.dx * dt;\n        this.x = Math.round(this.x);\n        if (!this.canCollide) {\n            return;\n        }\n        if (this.dx < 0) {\n            if (this.isTouchingTile(this.level.tiles, PhysicTile.Wall, { dir: Dir.Left })) {\n                this.onLeftCollision();\n            }\n        }\n        else if (this.dx > 0) {\n            if (this.isTouchingTile(this.level.tiles, PhysicTile.Wall, { dir: Dir.Right })) {\n                this.onRightCollision();\n            }\n        }\n    }\n    moveY(dt) {\n        this.y += this.dy * dt;\n        this.y = Math.round(this.y);\n        if (!this.canCollide) {\n            return;\n        }\n        if (this.dy < 0) {\n            if (this.isTouchingTile(this.level.tiles, PhysicTile.Wall, { dir: Dir.Up })) {\n                this.onUpCollision();\n            }\n        }\n        else if (this.dy > 0) {\n            if (this.isTouchingTile(this.level.tiles, PhysicTile.Wall, { dir: Dir.Down })) {\n                this.onDownCollision();\n            }\n        }\n    }\n    onLeftCollision() {\n        const resetPos = this.level.tiles.getTileCoordFromCoord({ x: this.minX, y: 0 }, { x: 1, y: 0 });\n        this.minX = resetPos.x + 1;\n        this.dx = 0;\n    }\n    onRightCollision() {\n        const resetPos = this.level.tiles.getTileCoordFromCoord({ x: this.maxX, y: 0 }, { x: 0, y: 0 });\n        this.maxX = resetPos.x - 1;\n        this.dx = 0;\n    }\n    onUpCollision() {\n        const resetPos = this.level.tiles.getTileCoordFromCoord({ x: 0, y: this.minY }, { x: 0, y: 1 });\n        this.minY = resetPos.y + 1;\n        this.dy = 0;\n    }\n    onDownCollision() {\n        const resetPos = this.level.tiles.getTileCoordFromCoord({ x: 0, y: this.maxY }, { x: 0, y: 0 });\n        this.maxY = resetPos.y - 1;\n        this.dy = 0;\n    }\n    isTouchingTile(tileSource, tile, { dir = undefined, offset = undefined } = {}) {\n        if (!Array.isArray(tile)) {\n            tile = [tile];\n        }\n        const corners = Dirs.cornersInDirection(dir);\n        for (const corner of corners) {\n            const x = this.x + corner.x * this.w + (offset?.x ?? 0);\n            const y = this.y + corner.y * this.h + (offset?.y ?? 0);\n            for (const t of tile) {\n                if (tileSource.getTileAtCoord({ x, y }) === t) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    isTouchingEntity(other) {\n        return this.maxX > other.minX && this.minX < other.maxX && this.maxY > other.minY && this.minY < other.maxY;\n    }\n    render(context) {\n        if (this.debugColor) {\n            context.fillStyle = this.debugColor;\n            context.fillRect(this.x, this.y, this.w, this.h);\n            // console.log(`Rendering entity at ${this.x}, ${this.y} with size ${this.w}, ${this.h}`);\n        }\n    }\n    //#region Getters and setter for min / mid / max.\n    get minX() {\n        return this.x;\n    }\n    get minY() {\n        return this.y;\n    }\n    get maxX() {\n        return this.x + this.w;\n    }\n    get maxY() {\n        return this.y + this.h;\n    }\n    get midX() {\n        return this.x + this.w / 2;\n    }\n    get midY() {\n        return this.y + this.h / 2;\n    }\n    set minX(val) {\n        this.x = val;\n    }\n    set minY(val) {\n        this.y = val;\n    }\n    set maxX(val) {\n        this.x = val - this.w;\n    }\n    set maxY(val) {\n        this.y = val - this.h;\n    }\n    set midX(val) {\n        this.x = val - this.w / 2;\n    }\n    set midY(val) {\n        this.y = val - this.h / 2;\n    }\n}\n","import { DOWN_KEYS, FPS, LEFT_KEYS, PHYSICS_SCALE, RIGHT_KEYS, UP_KEYS, physFromPx } from \"../../constants\";\nimport { Aseprite } from \"../../lib/aseprite\";\nimport { NullKeys } from \"../../lib/keys\";\nimport { ObjectTile } from \"../tile/object-layer\";\nimport { Entity } from \"./entity\";\nconst imageName = 'player';\nexport class Player extends Entity {\n    constructor(level) {\n        super(level);\n        this.runSpeed = 1.3 * PHYSICS_SCALE * FPS;\n        this.controlledByPlayer = true;\n        // TODO: Set w and h\n        this.w = physFromPx(10);\n        this.h = physFromPx(10);\n    }\n    getAnimationName() {\n        let animName = 'idle';\n        let loop = true;\n        return { animName, loop };\n    }\n    render(context) {\n        super.render(context);\n        const { animName, loop } = this.getAnimationName();\n        Aseprite.drawAnimation({\n            context,\n            image: \"player\",\n            animationName: animName,\n            time: this.animCount,\n            position: { x: this.midX, y: this.maxY },\n            scale: PHYSICS_SCALE,\n            anchorRatios: { x: 0.5, y: 1 },\n            loop,\n        });\n    }\n    cameraFocus() {\n        return { x: this.midX, y: this.maxY };\n    }\n    update(dt) {\n        this.animCount += dt;\n        // TODO: Maybe checking what animation frame we're add and playing a sound effect (e.g. if it's a footstep frame.)\n        let keys = this.controlledByPlayer ? this.level.game.keys : new NullKeys();\n        const left = keys.anyIsPressed(LEFT_KEYS);\n        const right = keys.anyIsPressed(RIGHT_KEYS);\n        const up = keys.anyIsPressed(UP_KEYS);\n        const down = keys.anyIsPressed(DOWN_KEYS);\n        // TODO: Record this somehow.\n        // Also TODO: Damping to make this smooth.\n        if (left && !right) {\n            this.dx = -this.runSpeed;\n        }\n        else if (right && !left) {\n            this.dx = this.runSpeed;\n        }\n        else {\n            this.dx = 0;\n        }\n        if (up && !down) {\n            this.dy = -this.runSpeed;\n        }\n        else if (down && !up) {\n            this.dy = this.runSpeed;\n        }\n        else {\n            this.dy = 0;\n        }\n        this.moveX(dt);\n        this.moveY(dt);\n        // Checking for winning\n        if (this.isTouchingTile(this.level.tiles.objectLayer, ObjectTile.Goal)) {\n            this.level.win();\n        }\n    }\n    static async preload() {\n        await Aseprite.loadImage({ name: imageName, basePath: 'sprites' });\n    }\n}\n","import { GAME_HEIGHT_PX, GAME_WIDTH_PX, PHYSICS_SCALE, RESTART_KEYS, TIME_STEP } from \"../constants\";\nimport { Aseprite } from \"../lib/aseprite\";\nimport { KeyboardKeys, NullKeys } from \"../lib/keys\";\nimport { Sounds } from \"../lib/sounds\";\nimport { Background } from \"./background\";\nimport { centerCanvas } from \"./camera\";\nimport { Player } from \"./entity/player\";\nimport { Level } from \"./level\";\nimport { LEVELS, Levels } from \"./levels\";\nimport { SFX } from \"./sfx\";\nimport { Tiles } from \"./tile/tiles\";\nexport class Game {\n    constructor(canvasSelector) {\n        this.scale = 1;\n        this.levelIndex = 0;\n        this.showingTitle = true;\n        this.nullKeys = new NullKeys();\n        const canvas = document.querySelector(canvasSelector);\n        if (!canvas) {\n            throw new Error(`Could not find canvas with selector ${canvasSelector}`);\n        }\n        const context = canvas.getContext('2d');\n        this.canvas = canvas;\n        this.context = context;\n        this.keys = new KeyboardKeys();\n        Sounds.loadMuteState();\n    }\n    start() {\n        this.keys.setUp();\n        Aseprite.disableSmoothing(this.context);\n        this.resize();\n        window.addEventListener('resize', () => this.resize());\n        // Whenever any touch event happens, try to enter fullscreen.\n        window.addEventListener('touchstart', () => this.enterFullscreen());\n        this.doAnimationLoop();\n        this.startLevel(0);\n    }\n    nextLevel() {\n        this.startLevel((this.levelIndex + 1) % LEVELS.length);\n    }\n    prevLevel() {\n        this.startLevel((this.levelIndex + LEVELS.length - 1) % LEVELS.length);\n    }\n    startLevel(levelIndex) {\n        this.levelIndex = levelIndex;\n        const levelInfo = LEVELS[this.levelIndex];\n        const level = new Level(this, levelInfo);\n        level.initFromImage();\n        this.curLevel = level;\n        // if (levelInfo.song) {\n        //     Sounds.setSong(levelInfo.song);\n        // }\n    }\n    win() {\n        this.nextLevel();\n    }\n    doAnimationLoop() {\n        if (this.simulatedTimeMs == undefined) {\n            this.simulatedTimeMs = Date.now();\n        }\n        let curTime = Date.now();\n        let updateCount = 0;\n        while (this.simulatedTimeMs < curTime) {\n            this.update(TIME_STEP);\n            this.simulatedTimeMs += 1000 * TIME_STEP;\n            updateCount++;\n            if (updateCount > 10) {\n                this.simulatedTimeMs = curTime;\n                break;\n            }\n        }\n        this.render();\n        requestAnimationFrame(() => this.doAnimationLoop());\n    }\n    handleInput() {\n        if (this.keys.wasPressedThisFrame('KeyM')) {\n            // Mute\n            Sounds.toggleMute();\n        }\n        // Debug:\n        if (this.keys.wasPressedThisFrame('Comma')) {\n            this.prevLevel();\n        }\n        if (this.keys.wasPressedThisFrame('Period')) {\n            this.nextLevel();\n        }\n        if (this.keys.anyWasPressedThisFrame(RESTART_KEYS)) {\n            this.startLevel(this.levelIndex);\n        }\n    }\n    update(dt) {\n        try {\n            this.handleInput();\n            this.curLevel?.update(dt);\n            this.keys.resetFrame();\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    applyScale(context) {\n        context.scale(this.scale, this.scale);\n    }\n    render() {\n        this.context.resetTransform();\n        centerCanvas(this.context);\n        this.applyScale(this.context);\n        try {\n            this.curLevel?.render(this.context);\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    resize() {\n        const windowWidth = window.innerWidth;\n        const windowHeight = window.innerHeight;\n        const pixelScale = window.devicePixelRatio || 1;\n        // Set canvas size\n        const xScale = windowWidth / GAME_WIDTH_PX;\n        const yScale = windowHeight / GAME_HEIGHT_PX;\n        // Math.min = scale to fit\n        const pxScale = Math.floor(Math.min(xScale, yScale) * pixelScale);\n        this.scale = pxScale / PHYSICS_SCALE;\n        document.body.style.setProperty('--scale', `${pxScale / pixelScale}`);\n        this.canvas.width = windowWidth * pixelScale;\n        this.canvas.height = windowHeight * pixelScale;\n        this.canvas.style.width = `${windowWidth}px`;\n        this.canvas.style.height = `${windowHeight}px`;\n        // Need to call this again when the canvas size changes.\n        Aseprite.disableSmoothing(this.context);\n        // Set HTML element size\n        document.body.style.setProperty('--pageWidth', `${windowWidth}px`);\n        document.body.style.setProperty('--pageHeight', `${windowHeight}px`);\n    }\n    enterFullscreen() {\n        // If we're already fullscreen, don't do anything.\n        if (document.fullscreenElement) {\n            return;\n        }\n        const elem = document.documentElement;\n        if (elem.requestFullscreen) {\n            elem.requestFullscreen();\n        }\n    }\n    static async preload() {\n        await Promise.all([\n            Levels.preload(),\n            Tiles.preload(),\n            Player.preload(),\n            Background.preload(),\n        ]);\n        SFX.preload();\n    }\n}\n","import { TILE_SIZE_PX } from \"../constants\";\nimport { Images } from \"../lib/images\";\nimport { Background } from \"./background\";\nimport { FocusCamera } from \"./camera\";\nimport { Player } from \"./entity/player\";\nimport { BaseTile } from \"./tile/base-layer\";\nimport { ObjectTile } from \"./tile/object-layer\";\nimport { Tiles } from \"./tile/tiles\";\n// Contains everything in one level, including the tiles and the entities.\nexport class Level {\n    constructor(game, levelInfo) {\n        this.entities = [];\n        this.camera = new FocusCamera();\n        this.tiles = new Tiles(0, 0);\n        this.start = { x: 0, y: 0 };\n        this.won = false;\n        this.game = game;\n        this.levelInfo = levelInfo;\n    }\n    initFromImage() {\n        const image = Images.images[this.levelInfo.name].image;\n        this.image = image;\n        this.entities = [];\n        this.tiles = new Tiles(image.width, image.height);\n        this.background = new Background(this, {\n            x: TILE_SIZE_PX * image.width / 2,\n            y: TILE_SIZE_PX * image.height / 2,\n        });\n        // Draw the image to a canvas to get the pixels.\n        const canvas = document.createElement('canvas');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext('2d');\n        context.drawImage(image, 0, 0, image.width, image.height);\n        // Read the pixels. White is empty, black is wall, and the red square is the starting position.\n        const imageData = context.getImageData(0, 0, image.width, image.height);\n        for (let y = 0; y < image.height; y++) {\n            for (let x = 0; x < image.width; x++) {\n                const basePos = this.tiles.getTileCoord({ x, y }, { x: 0.5, y: 1 });\n                const color = pixelToColorString(imageData, x, y);\n                if (color === 'ffffff') {\n                    // Don't need to do anything for empty tiles as they're the default.\n                }\n                else if (color === '000000') {\n                    this.tiles.baseLayer.setTile({ x, y }, BaseTile.Wall, { allowGrow: false });\n                }\n                else if (color === 'aaaaaa') {\n                    this.tiles.baseLayer.setTile({ x, y }, BaseTile.Background, { allowGrow: false });\n                }\n                else if (color === 'ffff00') {\n                    this.tiles.objectLayer.setTile({ x, y }, ObjectTile.Goal, { allowGrow: false });\n                    this.tiles.baseLayer.setTile({ x, y }, BaseTile.Unknown, { allowGrow: false });\n                }\n                else if (color === 'ff0000') {\n                    this.start = basePos;\n                    this.tiles.objectLayer.setTile({ x, y }, ObjectTile.Spawn, { allowGrow: false });\n                    this.tiles.baseLayer.setTile({ x, y }, BaseTile.Unknown, { allowGrow: false });\n                }\n                else if (color === '0000ff') {\n                    this.tiles.objectLayer.setTile({ x, y }, ObjectTile.Platform, { allowGrow: false });\n                    this.tiles.baseLayer.setTile({ x, y }, BaseTile.Unknown, { allowGrow: false });\n                }\n                else {\n                    console.log(`Unknown color: ${color} at ${x}, ${y}.`);\n                }\n            }\n        }\n        this.tiles.baseLayer.fillInUnknownTiles();\n        // this.camera.target = () => ({x: this.start.x, y: this.start.y});\n        this.spawnPlayer();\n    }\n    spawnPlayer() {\n        const player = new Player(this);\n        player.midX = this.start.x;\n        player.maxY = this.start.y;\n        this.entities.push(player);\n        this.camera.target = () => player.cameraFocus();\n    }\n    update(dt) {\n        for (const entity of this.entities) {\n            entity.update(dt);\n        }\n        for (let i = this.entities.length - 1; i >= 0; i--) {\n            if (this.entities[i].done) {\n                this.entities.splice(i, 1);\n            }\n        }\n        this.background?.update(dt);\n        this.tiles.update(dt);\n        this.camera.update(dt);\n    }\n    render(context) {\n        this.camera.applyTransform(context);\n        this.background?.render(context);\n        this.tiles.render(context);\n        for (const entity of this.entities) {\n            entity.render(context);\n        }\n    }\n    win() {\n        this.won = true;\n        this.game.win();\n    }\n}\nfunction pixelToColorString(imageData, x, y) {\n    const i = (y * imageData.width + x) * 4;\n    const r = imageData.data[i];\n    const g = imageData.data[i + 1];\n    const b = imageData.data[i + 2];\n    return r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');\n}\n","import { Images } from \"../lib/images\";\nimport { Sounds } from \"../lib/sounds\";\nexport const LEVELS = [\n    {\n        name: 'level1',\n    },\n    {\n        name: 'level2',\n    },\n];\nexport class Levels {\n    static preload() {\n        const promises = [];\n        for (const level of LEVELS) {\n            promises.push(Images.loadImage({ name: level.name, path: 'level/', extension: 'gif' }));\n            if (level.song && Sounds.audios[level.song] === undefined) {\n                promises.push(Sounds.loadSound({ name: level.song, path: 'music/' }));\n            }\n        }\n        return Promise.all(promises);\n    }\n}\n","// @ts-ignore\nimport { sfxr } from \"jsfxr\";\nimport { MuteState, Sounds } from \"../lib/sounds\";\nconst sfx = {};\nclass _SFX {\n    constructor() {\n        this.sounds = {};\n    }\n    preload() {\n        for (let key in sfx) {\n            this.sounds[key] = sfxr.toAudio(sfx[key]);\n        }\n    }\n    play(name) {\n        if (Sounds.muteState === MuteState.ALL_OFF) {\n            return;\n        }\n        const sound = this.sounds[name];\n        if (sound) {\n            sound.play();\n        }\n    }\n}\nexport const SFX = new _SFX();\n","import { TILE_SIZE } from \"../../constants\";\nimport { TileLayer } from \"./tile-layer\";\nexport var BaseTile;\n(function (BaseTile) {\n    BaseTile[BaseTile[\"Empty\"] = 0] = \"Empty\";\n    BaseTile[BaseTile[\"Wall\"] = 1] = \"Wall\";\n    BaseTile[BaseTile[\"Background\"] = 2] = \"Background\";\n    BaseTile[BaseTile[\"Unknown\"] = 3] = \"Unknown\";\n})(BaseTile || (BaseTile = {}));\nexport class BaseLayer extends TileLayer {\n    constructor(w, h) {\n        super(w, h);\n        // // Add a floor and some walls.\n        // for (let y = 0; y < this.h; y++) {\n        //     for (let x = 0; x < this.w; x++) {\n        //         this.tiles[y][x] = y == (this.h - 1) ? BaseTile.Wall : BaseTile.Empty;\n        //     }\n        //     this.tiles[y][0] = BaseTile.Wall;\n        //     this.tiles[y][this.w - 1] = BaseTile.Wall;\n        // }\n    }\n    fillInUnknownTiles() {\n        for (let y = this.minY; y <= this.maxY; y++) {\n            for (let x = this.minX; x <= this.maxX; x++) {\n                if (this.getTile({ x, y }) == BaseTile.Unknown) {\n                    console.log('filling in unknown tile', x, y);\n                    // Unknown tiles are filled based on the tile to the left and right.\n                    const horizontalTiles = [\n                        this.getTile({ x: x - 1, y }),\n                        this.getTile({ x: x + 1, y }),\n                    ];\n                    let newTile = this.pickTileToFillUnknown(horizontalTiles);\n                    this.setTile({ x, y }, newTile);\n                }\n            }\n        }\n    }\n    pickTileToFillUnknown(neighbors) {\n        // Filter out walls.\n        const filteredNeighbors = neighbors.filter((tile) => tile != BaseTile.Wall);\n        // Sort them (sort of a hack but works ok).\n        const sortedNeighbors = filteredNeighbors.sort();\n        // Because there's just two, we don't need to do the whole sorting thing... just pick the first.\n        // If this is empty, there are two walls. We use the background tile for that case.\n        return sortedNeighbors.length > 0 ? sortedNeighbors[0] : BaseTile.Background;\n    }\n    renderTile(context, pos) {\n        const tile = this.getTile(pos);\n        const renderPos = { x: pos.x * TILE_SIZE, y: pos.y * TILE_SIZE };\n        if (tile == BaseTile.Wall) {\n            // Loop through each corner\n            for (const dx of [-1, 1]) {\n                const dxTile = this.getTile({ x: pos.x + dx, y: pos.y });\n                for (const dy of [-1, 1]) {\n                    const subTilePos = { x: dx < 0 ? 0 : 1, y: dy < 0 ? 0 : 1 };\n                    const dyTile = this.getTile({ x: pos.x, y: pos.y + dy });\n                    const dxdyTile = this.getTile({ x: pos.x + dx, y: pos.y + dy });\n                    let tilePos = { x: 0, y: 0 };\n                    switch (dxTile) {\n                        case BaseTile.Wall:\n                            tilePos.x += 1;\n                            break;\n                        case BaseTile.Background:\n                            tilePos.x += 2;\n                            break;\n                    }\n                    switch (dyTile) {\n                        case BaseTile.Wall:\n                            tilePos.y += 1;\n                            break;\n                    }\n                    // // Special case for the corner piece.\n                    // if (dxTile == BaseTile.Wall && dyTile == BaseTile.Wall && dxdyTile != BaseTile.Wall) {\n                    //     tilePos.y += 2;\n                    // }\n                    this.drawQuarterTile(context, {\n                        tilePos,\n                        subTilePos,\n                        renderPos\n                    });\n                }\n            }\n        }\n        else if (tile == BaseTile.Background) {\n            // A similar set of conditions as for the walls.\n            for (const dx of [-1, 1]) {\n                const dxTile = this.getTile({ x: pos.x + dx, y: pos.y });\n                for (const dy of [-1, 1]) {\n                    const subTilePos = { x: dx < 0 ? 0 : 1, y: dy < 0 ? 0 : 1 };\n                    const dyTile = this.getTile({ x: pos.x, y: pos.y + dy });\n                    let tilePos = { x: 3, y: 0 };\n                    switch (dxTile) {\n                        case BaseTile.Background:\n                        case BaseTile.Wall:\n                            tilePos.x += 1;\n                            break;\n                    }\n                    switch (dyTile) {\n                        case BaseTile.Background:\n                            tilePos.y += 1;\n                            break;\n                        case BaseTile.Wall:\n                            tilePos.y += 2;\n                            break;\n                    }\n                    this.drawQuarterTile(context, {\n                        tilePos,\n                        subTilePos,\n                        renderPos\n                    });\n                }\n            }\n        }\n    }\n}\n","import { TILE_SIZE } from \"../../constants\";\nimport { TileLayer } from \"./tile-layer\";\nexport var ObjectTile;\n(function (ObjectTile) {\n    ObjectTile[ObjectTile[\"Empty\"] = 0] = \"Empty\";\n    ObjectTile[ObjectTile[\"Spawn\"] = 1] = \"Spawn\";\n    ObjectTile[ObjectTile[\"Goal\"] = 2] = \"Goal\";\n    ObjectTile[ObjectTile[\"Platform\"] = 3] = \"Platform\";\n})(ObjectTile || (ObjectTile = {}));\n// Position of the tile in the tileset.\nconst tilePositions = {\n    [ObjectTile.Spawn]: { x: 6, y: 0 },\n    [ObjectTile.Goal]: { x: 7, y: 0 },\n    [ObjectTile.Platform]: { x: 6, y: 1 },\n};\nexport class ObjectLayer extends TileLayer {\n    renderTile(context, pos) {\n        const tile = this.getTile(pos);\n        const renderPos = { x: pos.x * TILE_SIZE, y: pos.y * TILE_SIZE };\n        const tilePos = tilePositions[tile];\n        if (!tilePos) {\n            return;\n        }\n        this.drawTile(context, { tilePos, renderPos });\n    }\n}\n","import { TILE_SIZE, TILE_SIZE_PX } from \"../../constants\";\nimport { Images } from \"../../lib/images\";\n/**\n * 2D array of tiles.\n */\nexport class TileLayer {\n    constructor(w, h) {\n        this.tiles = [];\n        this.w = 0;\n        this.h = 0;\n        // Index of the top left corner of this level. Can move when the level grows.\n        this.x = 0;\n        this.y = 0;\n        this.animCount = 0;\n        this.w = w;\n        this.h = h;\n        // Fill with the zero value.\n        for (let y = 0; y < this.h; y++) {\n            this.tiles[y] = [];\n            for (let x = 0; x < this.w; x++) {\n                this.tiles[y][x] = 0;\n            }\n        }\n    }\n    update(dt) {\n        this.animCount += dt;\n    }\n    render(context) {\n        if (!this.image) {\n            const imageInfo = Images.images[\"tiles\"];\n            if (!imageInfo.loaded) {\n                return;\n            }\n            this.image = imageInfo.image;\n        }\n        const invMatrix = context.getTransform().inverse();\n        const gameMinPoint = invMatrix.transformPoint({ x: 0, y: 0 });\n        const gameMaxPoint = invMatrix.transformPoint({\n            x: context.canvas.width,\n            y: context.canvas.height,\n        });\n        const minXTile = Math.floor(gameMinPoint.x / TILE_SIZE);\n        const minYTile = Math.floor(gameMinPoint.y / TILE_SIZE);\n        const maxXTile = Math.floor(gameMaxPoint.x / TILE_SIZE);\n        const maxYTile = Math.floor(gameMaxPoint.y / TILE_SIZE);\n        for (let y = minYTile; y <= maxYTile; y++) {\n            for (let x = minXTile; x <= maxXTile; x++) {\n                this.renderTile(context, { x, y });\n            }\n        }\n    }\n    renderTile(context, pos) {\n        // Logic handled per layer.\n    }\n    drawTile(context, { tilePos, renderPos, }) {\n        // Image must be loaded when this is called.\n        context.drawImage(this.image, tilePos.x * TILE_SIZE_PX, tilePos.y * TILE_SIZE_PX, TILE_SIZE_PX, TILE_SIZE_PX, renderPos.x, renderPos.y, \n        // +1 is a kludge to avoid gaps between tiles.\n        TILE_SIZE + 1, TILE_SIZE + 1);\n    }\n    drawQuarterTile(context, { tilePos, subTilePos, renderPos, }) {\n        // Image must be loaded when this is called.\n        const halfTileSizePx = TILE_SIZE_PX / 2;\n        const halfTileSize = TILE_SIZE / 2;\n        context.drawImage(this.image, tilePos.x * TILE_SIZE_PX + subTilePos.x * halfTileSizePx, tilePos.y * TILE_SIZE_PX + subTilePos.y * halfTileSizePx, halfTileSizePx, halfTileSizePx, renderPos.x + subTilePos.x * halfTileSize, renderPos.y + subTilePos.y * halfTileSize, \n        // +1 is a kludge to avoid gaps between tiles.\n        halfTileSize + 1, halfTileSize + 1);\n    }\n    setTile(p, tile, { allowGrow = true } = {}) {\n        // If out of bounds, extend the board!\n        let y = p.y;\n        while (allowGrow && y + this.y < 1) {\n            this.tiles.unshift(this.tiles[0].slice());\n            this.y++;\n            this.h++;\n        }\n        while (allowGrow && y + this.y >= this.h - 1) {\n            this.tiles.push(this.tiles[this.h - 1].slice());\n            this.h++;\n        }\n        let x = p.x;\n        while (allowGrow && x + this.x < 1) {\n            for (let y = 0; y < this.h; y++) {\n                this.tiles[y].unshift(this.tiles[y][0]);\n            }\n            this.x++;\n            this.w++;\n        }\n        while (allowGrow && x + this.x >= this.w - 1) {\n            for (let y = 0; y < this.h; y++) {\n                this.tiles[y].push(this.tiles[y][this.w - 1]);\n            }\n            this.w++;\n        }\n        // Check if we're out of bounds, for when allowGrow is false.\n        if (p.x + this.x < 0 || p.y + this.y < 0 || p.x + this.x >= this.w || p.y + this.y >= this.h) {\n            throw new Error(`Tile out of bounds: ${p.x}, ${p.y}`);\n        }\n        this.tiles[p.y + this.y][p.x + this.x] = tile;\n    }\n    setTileAtCoord(p, tile, { allowGrow = true } = {}) {\n        this.setTile({\n            x: Math.floor(p.x / TILE_SIZE),\n            y: Math.floor(p.y / TILE_SIZE),\n        }, tile, { allowGrow });\n    }\n    getTile(p) {\n        let x = Math.min(Math.max(p.x + this.x, 0), this.w - 1);\n        let y = Math.min(Math.max(p.y + this.y, 0), this.h - 1);\n        return this.tiles[y][x];\n    }\n    getTileAtCoord(p) {\n        return this.getTile({\n            x: Math.floor(p.x / TILE_SIZE),\n            y: Math.floor(p.y / TILE_SIZE),\n        });\n    }\n    get minX() {\n        return this.x;\n    }\n    get minY() {\n        return this.y;\n    }\n    get maxX() {\n        return this.x + this.w - 1;\n    }\n    get maxY() {\n        return this.y + this.h - 1;\n    }\n}\n","import { TILE_SIZE } from \"../../constants\";\nimport { Images } from \"../../lib/images\";\nimport { BaseLayer, BaseTile } from \"./base-layer\";\nimport { ObjectLayer, ObjectTile } from \"./object-layer\";\n// All the types of tiles as far as how they interact with the game physics.\nexport var PhysicTile;\n(function (PhysicTile) {\n    PhysicTile[PhysicTile[\"Empty\"] = 0] = \"Empty\";\n    PhysicTile[PhysicTile[\"Wall\"] = 1] = \"Wall\";\n    PhysicTile[PhysicTile[\"OneWayPlatform\"] = 2] = \"OneWayPlatform\";\n})(PhysicTile || (PhysicTile = {}));\n/**\n * 2D array of tiles.\n */\nexport class Tiles {\n    constructor(w, h) {\n        this.baseLayer = new BaseLayer(w, h);\n        this.objectLayer = new ObjectLayer(w, h);\n    }\n    update(dt) {\n        this.baseLayer.update(dt);\n        this.objectLayer.update(dt);\n    }\n    render(context) {\n        this.baseLayer.render(context);\n        this.objectLayer.render(context);\n    }\n    getTileCoord(p, positionInTile) {\n        return {\n            x: p.x * TILE_SIZE + (TILE_SIZE - 1) * positionInTile.x,\n            y: p.y * TILE_SIZE + (TILE_SIZE - 1) * positionInTile.y,\n        };\n    }\n    getTileCoordFromCoord(p, positionInTile) {\n        return this.getTileCoord({ x: Math.floor(p.x / TILE_SIZE), y: Math.floor(p.y / TILE_SIZE) }, positionInTile);\n    }\n    static async preload() {\n        await Images.loadImage({ name: \"tiles\", path: \"sprites/\" });\n    }\n    getTile(p) {\n        const baseTile = this.baseLayer.getTile(p);\n        if (baseTile == BaseTile.Wall) {\n            return PhysicTile.Wall;\n        }\n        const objectTile = this.objectLayer.getTile(p);\n        if (objectTile == ObjectTile.Platform) {\n            return PhysicTile.OneWayPlatform;\n        }\n        return PhysicTile.Empty;\n    }\n    getTileAtCoord(p) {\n        return this.getTile({\n            x: Math.floor(p.x / TILE_SIZE),\n            y: Math.floor(p.y / TILE_SIZE),\n        });\n    }\n}\n","/**\n * Map of all the images and their metadata.\n *\n * Treat this as read-only, but if you need to access information like the\n * lengths of animations you can use this.\n */\nexport const images = {};\n/**\n * Preloads multiple images.\n *\n * See `loadImage` for more info.\n */\nexport function loadImages(imageInfos) {\n    const promises = [];\n    for (const imageInfo of imageInfos) {\n        promises.push(loadImage(imageInfo));\n    }\n    return Promise.all(promises);\n}\n/**\n * Asynchronously fetches an image and it's associated metadata, and saves it in\n * the images map.\n *\n * You can either use `basePath` to specify the directory that contains both the\n * image and its metadata, or you can specify the full path to each using\n * `imagePath` and `jsonPath`. If you specify just the directory, the files need\n * to be called [name].png and [name].json.\n */\nexport function loadImage({ name, basePath = undefined, imagePath = undefined, jsonPath = undefined, }) {\n    if (!basePath && (!imagePath || !jsonPath)) {\n        return Promise.reject(\"Must specify either a basePath or imagePath and jsonPath\");\n    }\n    if (images.hasOwnProperty(name)) {\n        return Promise.resolve(images[name]);\n    }\n    if (!imagePath || !jsonPath) {\n        // As this stage we know basePath is defined, so force the compiler to\n        // acknowledge that.\n        basePath = basePath;\n        if (!basePath.endsWith(\"/\")) {\n            basePath = basePath + \"/\";\n        }\n        imagePath = `${basePath}${name}.png`;\n        jsonPath = `${basePath}${name}.json`;\n    }\n    images[name] = {\n        name,\n        imageLoaded: false,\n        jsonLoaded: false,\n        loaded: false,\n        animations: {},\n    };\n    const imageLoadedPromise = new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => {\n            images[name].image = image;\n            images[name].imageLoaded = true;\n            images[name].loaded = images[name].jsonLoaded;\n            resolve();\n        };\n        image.onerror = () => {\n            reject(`Error loading image ${name}.`);\n        };\n        image.src = imagePath;\n    });\n    // Load JSON metadata.\n    const jsonLoadedPromise = fetch(jsonPath)\n        .then((response) => {\n        if (response.status != 200) {\n            throw new Error(`Couldn't load json metadata for image ${name}.`);\n        }\n        return response.json();\n    })\n        .then((response) => {\n        // Note: This currently ignores direction.\n        const animations = {};\n        for (const animData of response.meta.frameTags) {\n            let length = 0;\n            for (let i = animData.from; i <= animData.to; i++) {\n                length += response.frames[i].duration;\n            }\n            animations[animData.name] = {\n                from: animData.from,\n                to: animData.to,\n                length,\n            };\n        }\n        images[name].animations = animations;\n        images[name].frames = response.frames;\n        images[name].jsonLoaded = true;\n        images[name].loaded = images[name].imageLoaded;\n    });\n    const allLoadedPromise = Promise.all([\n        imageLoadedPromise,\n        jsonLoadedPromise,\n    ]).then(() => images[name]);\n    images[name].loadPromise = allLoadedPromise;\n    return allLoadedPromise;\n}\nfunction applyEffect(name, newName, effectFn) {\n    if (images[newName] != undefined) {\n        return images[newName];\n    }\n    if (!images.hasOwnProperty(name)) {\n        throw new Error(`Cannot apply filter to image ${name} as it doesn\\'t exist.`);\n    }\n    const baseImageMetadata = images[name];\n    if (baseImageMetadata.image == null) {\n        throw new Error(`Can't generate filtered image until base image is loaded.`);\n    }\n    images[newName] = {\n        name: newName,\n        imageLoaded: false,\n        jsonLoaded: true,\n        loaded: false,\n        animations: baseImageMetadata.animations,\n        frames: baseImageMetadata.frames,\n    };\n    const canvas = effectFn(baseImageMetadata.image);\n    const imageLoadedPromise = new Promise((resolve, reject) => {\n        const image = new Image();\n        // Even though we're setting the source from a data url, it still needs to load.\n        image.onload = () => {\n            images[newName].image = image;\n            images[newName].imageLoaded = true;\n            images[newName].loaded = true;\n            resolve();\n        };\n        image.onerror = () => {\n            reject(`Error loading image ${newName}.`);\n        };\n        image.src = canvas.toDataURL();\n    });\n    images[newName].loadPromise = imageLoadedPromise.then(() => images[newName]);\n    return images[newName];\n}\n/**\n * Applies a filter on an image, and caches the result.\n *\n * @param {string} name Name of the existing image\n * @param {string} filter Filter to apply\n * @returns {!ImageMetadata} new metadata of the filtered image.\n */\nexport function applyFilter(name, filter) {\n    const filteredImageName = getFilteredName(name, filter);\n    return applyEffect(name, filteredImageName, (image) => {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext(\"2d\");\n        context.filter = filter;\n        context.drawImage(image, 0, 0);\n        return canvas;\n    });\n}\n/**\n * @param {string} name Name of the existing image\n * @param {string} filter Filter to apply\n */\nfunction getFilteredName(name, filter) {\n    return name + \":filter=\" + filter;\n}\nexport function applyColorMap(name, colorMap) {\n    const colorMapName = getColorMapName(name, colorMap);\n    return applyEffect(name, colorMapName, (image) => {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(image, 0, 0);\n        for (let y = 0; y < image.height; y++) {\n            for (let x = 0; x < image.width; x++) {\n                const color = context.getImageData(x, y, 1, 1).data;\n                const r = color[0];\n                const g = color[1];\n                const b = color[2];\n                const colorHex = `#${r.toString(16)}${g.toString(16)}${b.toString(16)}`;\n                if (colorMap.hasOwnProperty(colorHex)) {\n                    const newColor = colorMap[colorHex];\n                    context.fillStyle = newColor;\n                    context.fillRect(x, y, 1, 1);\n                }\n            }\n        }\n        return canvas;\n    });\n}\n/**\n * @param {string} name Name of the existing image\n * @param {string} colorMap Filter to apply\n */\nfunction getColorMapName(name, colorMap) {\n    const keys = Object.keys(colorMap).sort();\n    return (name + \":colormap=\" + keys.map((k) => `${k}:${colorMap[k]}`).join(\",\"));\n}\n/**\n * Renders a specific frame to a canvas.\n *\n * @param p - Input to this function, as an object.\n * @param p.context - The context of the canvas to draw on.\n * @param p.image - The name, or image metadata of the spritesheet to draw.\n * @param p.frame - The frame number to draw.\n * @param p.position - The position on the canvas to draw this sprite\n * @param p.scale - How much to upscale the sprite. Should be an integer.\n * @param p.anchorRatios - The relative position of the anchor on this sprite.\n *     The anchor is used for positioning the sprite and for scaling. 0 puts\n *     the anchor at the left or the top, 1 puts the anchor at the right or the\n *     bottom. 0.5 positions the anchor at the center. Defaults to top left.\n * @param p.flipped Whether to flip the image horizontally.\n * @param p.filter A CSS filter to apply to the image. This will be cached for\n *     performance.\n * @returns True if it succeeded, false if the image wasn't loaded yet.\n */\nexport function drawSprite({ context, image, frame, position, scale = 1, anchorRatios = {\n    x: 0,\n    y: 0,\n}, flippedX = false, flippedY = false, filter, colorMap, }) {\n    if (typeof image === \"string\") {\n        image = images[image];\n    }\n    if (!image.loaded) {\n        return false;\n    }\n    if (filter && colorMap) {\n        throw new Error(\"Can't use both filter and color map on the same image.\");\n    }\n    if (filter != null && filter.length > 0) {\n        applyFilter(image.name, filter);\n        image = images[getFilteredName(image.name, filter)];\n        // The filtered image might not be loaded.\n        if (!image.loaded) {\n            return false;\n        }\n    }\n    if (colorMap != null && Object.keys(colorMap).length > 0) {\n        applyColorMap(image.name, colorMap);\n        image = images[getColorMapName(image.name, colorMap)];\n        // The color mapped image might not be loaded.\n        if (!image.loaded) {\n            return false;\n        }\n    }\n    if (!image.frames) {\n        return false;\n    }\n    const sourceRect = image.frames[frame].frame;\n    const destW = scale * sourceRect.w;\n    const destH = scale * sourceRect.h;\n    context.save();\n    context.translate(Math.round(position.x), Math.round(position.y));\n    const adjustedAnchorRatios = {\n        x: anchorRatios.x,\n        y: anchorRatios.y,\n    };\n    if (flippedX) {\n        context.scale(-1, 1);\n        adjustedAnchorRatios.x = 1 - adjustedAnchorRatios.x;\n    }\n    if (flippedY) {\n        context.scale(1, -1);\n        adjustedAnchorRatios.y = 1 - adjustedAnchorRatios.y;\n    }\n    context.drawImage(image.image, sourceRect.x, sourceRect.y, sourceRect.w, sourceRect.h, -adjustedAnchorRatios.x * destW, -adjustedAnchorRatios.y * destH, destW, destH);\n    context.restore();\n    return true;\n}\n/**\n * Renders a frame of an animation to the canvas, based on the input time.\n *\n * Assumes all animations loop.\n *\n * @param p - Input to this function, as an object.\n * @param p.context - The context of the canvas to draw on.\n * @param p.image - The name, or image metadata of the spritesheet to draw.\n * @param p.animationName - The name of the animation.\n * @param p.time - The position of this animation in time, relative to\n *     the start. In seconds. Determines which frame to render.\n * @param p.position - The position on the canvas to draw this sprite\n * @param p.scale - How much to upscale the sprite. Should be an integer.\n * @param p.anchorRatios - The relative position of the anchor on this sprite.\n *     The anchor is used for positioning the sprite and for scaling. 0 puts\n *     the anchor at the left or the top, 1 puts the anchor at the right or the\n *     bottom. 0.5 positions the anchor at the center. Defaults to top left.\n * @param p.flipped Whether to flip the image horizontally.\n * @param p.filter A CSS filter to apply to the image. This will be cached for\n *     performance.\n * @returns True if it succeeded, false if the image wasn't loaded yet.\n */\nexport function drawAnimation({ context, image, animationName, time, position, scale = 1, anchorRatios = {\n    x: 0,\n    y: 0,\n}, flippedX = false, flippedY = false, filter = \"\", loop = true }) {\n    if (typeof image === \"string\") {\n        image = images[image];\n    }\n    if (!image.loaded) {\n        return false;\n    }\n    const frame = getFrame(image, animationName, time, loop);\n    return drawSprite({\n        context,\n        image,\n        frame,\n        position,\n        scale,\n        anchorRatios,\n        flippedX,\n        flippedY,\n        filter,\n    });\n}\n/**\n * Figures out which frame of the animation we should draw.\n */\nexport function getFrame(image, animationName, time, loop = true) {\n    if (typeof image === \"string\") {\n        image = images[image];\n    }\n    if (!image.frames) {\n        return -1;\n    }\n    const animData = image.animations[animationName];\n    let localTimeMs = 1000 * time;\n    if (loop) {\n        localTimeMs %= animData.length;\n    }\n    else {\n        localTimeMs = Math.min(localTimeMs, animData.length - 1);\n    }\n    let cumulativeTimeMs = 0;\n    for (let i = animData.from; i <= animData.to; i++) {\n        cumulativeTimeMs += image.frames[i].duration;\n        if (cumulativeTimeMs > localTimeMs) {\n            return i;\n        }\n    }\n    throw new Error(`Something's wrong with the getFrame function`);\n}\n/**\n * Disables smoothing on the canvas across the different browsers.\n *\n * Keeps those pixels sharp!\n */\nexport function disableSmoothing(context) {\n    context.imageSmoothingEnabled = false;\n    context.msImageSmoothingEnabled = false;\n    context.webkitImageSmoothingEnabled = false;\n}\nexport const Aseprite = {\n    loadImage,\n    loadImages,\n    drawSprite,\n    drawAnimation,\n    disableSmoothing,\n    applyFilter,\n    getFrame,\n    get images() {\n        return images;\n    },\n};\n","export const images = {};\n/**\n * Asynchronously fetches an image.\n */\nexport function loadImage({ name, path, extension = 'png' }) {\n    const promise = new Promise((resolve, reject) => {\n        if (images.hasOwnProperty(name)) {\n            throw new Error(`Already loaded image ${name}.`);\n        }\n        if (!path.endsWith('/')) {\n            path = path + '/';\n        }\n        const imagePath = `${path}${name}.${extension}`;\n        images[name] = {\n            loaded: false,\n            image: undefined,\n        };\n        const image = new Image();\n        image.onload = () => {\n            images[name].image = image;\n            images[name].loaded = true;\n            resolve(images[name]);\n        };\n        image.onerror = () => {\n            reject(`Error loading image ${name}.`);\n        };\n        image.src = imagePath;\n    });\n    images[name].loadPromise = promise;\n    return promise;\n}\nexport const Images = {\n    loadImage,\n    images,\n};\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _KeyboardKeys_pressedKeys, _KeyboardKeys_pressedThisFrame, _KeyboardKeys_releasedThisFrame;\nconst disableDefaultKeys = new Set([\"Space\", \"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"]);\nexport class RegularKeys {\n    setUp() { }\n    resetFrame() { }\n    isPressed(keyCode) {\n        return false;\n    }\n    wasPressedThisFrame(keyCode) {\n        return false;\n    }\n    wasReleasedThisFrame(keyCode) {\n        return false;\n    }\n    anyIsPressed(keyCodes) {\n        for (const keyCode of keyCodes) {\n            if (this.isPressed(keyCode)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    anyWasPressedThisFrame(keyCodes) {\n        for (const keyCode of keyCodes) {\n            if (this.wasPressedThisFrame(keyCode)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    anyWasReleasedThisFrame(keyCodes) {\n        for (const keyCode of keyCodes) {\n            if (this.wasReleasedThisFrame(keyCode)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexport class KeyboardKeys extends RegularKeys {\n    constructor() {\n        super(...arguments);\n        _KeyboardKeys_pressedKeys.set(this, new Set());\n        _KeyboardKeys_pressedThisFrame.set(this, new Set());\n        _KeyboardKeys_releasedThisFrame.set(this, new Set());\n    }\n    setUp() {\n        // Thought: Should this be adding to a number rather than triggering a boolean? Eh.\n        document.addEventListener('keydown', (evt) => {\n            if (!__classPrivateFieldGet(this, _KeyboardKeys_pressedKeys, \"f\").has(evt.code)) {\n                __classPrivateFieldGet(this, _KeyboardKeys_pressedThisFrame, \"f\").add(evt.code);\n                // console.log(evt.code);\n            }\n            __classPrivateFieldGet(this, _KeyboardKeys_pressedKeys, \"f\").add(evt.code);\n            // Also disable scrolling\n            if (disableDefaultKeys.has(evt.code)) {\n                evt.preventDefault();\n            }\n        });\n        document.addEventListener('keyup', (evt) => {\n            __classPrivateFieldGet(this, _KeyboardKeys_pressedKeys, \"f\").delete(evt.code);\n            __classPrivateFieldGet(this, _KeyboardKeys_releasedThisFrame, \"f\").add(evt.code);\n        });\n    }\n    resetFrame() {\n        __classPrivateFieldGet(this, _KeyboardKeys_pressedThisFrame, \"f\").clear();\n        __classPrivateFieldGet(this, _KeyboardKeys_releasedThisFrame, \"f\").clear();\n    }\n    isPressed(keyCode) {\n        return __classPrivateFieldGet(this, _KeyboardKeys_pressedKeys, \"f\").has(keyCode);\n    }\n    wasPressedThisFrame(keyCode) {\n        return __classPrivateFieldGet(this, _KeyboardKeys_pressedThisFrame, \"f\").has(keyCode);\n    }\n    wasReleasedThisFrame(keyCode) {\n        return __classPrivateFieldGet(this, _KeyboardKeys_releasedThisFrame, \"f\").has(keyCode);\n    }\n}\n_KeyboardKeys_pressedKeys = new WeakMap(), _KeyboardKeys_pressedThisFrame = new WeakMap(), _KeyboardKeys_releasedThisFrame = new WeakMap();\nexport class ComboKeys extends RegularKeys {\n    constructor(...keys) {\n        super();\n        this.subKeys = keys;\n    }\n    setUp() {\n        this.subKeys.forEach(k => k.setUp());\n    }\n    resetFrame() {\n        this.subKeys.forEach(k => k.resetFrame());\n    }\n    isPressed(keyCode) {\n        return this.subKeys.some(k => k.isPressed(keyCode));\n    }\n    wasPressedThisFrame(keyCode) {\n        return this.subKeys.some(k => k.wasPressedThisFrame(keyCode));\n    }\n    wasReleasedThisFrame(keyCode) {\n        return this.subKeys.some(k => k.wasReleasedThisFrame(keyCode));\n    }\n}\nexport const NullKeys = RegularKeys;\n","import { lerp } from \"./util\";\nexport var MuteState;\n(function (MuteState) {\n    MuteState[MuteState[\"PLAY_ALL\"] = 0] = \"PLAY_ALL\";\n    MuteState[MuteState[\"MUSIC_OFF\"] = 1] = \"MUSIC_OFF\";\n    MuteState[MuteState[\"ALL_OFF\"] = 2] = \"ALL_OFF\";\n})(MuteState || (MuteState = {}));\n// Playing at 1 volume is too loud.\nconst VOLUME_MULTIPLE = 0.5;\nclass _Sounds {\n    constructor() {\n        this.audios = {};\n        this.muteState = MuteState.PLAY_ALL;\n        this.playbackRate = 1;\n        this.volume = 1;\n    }\n    /**\n     * Asynchronously fetches an audio.\n     */\n    loadSound({ name, path }) {\n        const promise = new Promise((resolve) => {\n            if (this.audios.hasOwnProperty(name)) {\n                throw new Error(`Already loaded sound ${name}.`);\n            }\n            if (!path.endsWith('/')) {\n                path = path + '/';\n            }\n            const audioPath = `${path}${name}.mp3`;\n            this.audios[name] = {\n                loaded: false,\n                audio: undefined,\n                loadPromise: promise,\n            };\n            const audio = new Audio();\n            audio.oncanplaythrough = () => {\n                this.audios[name].audio = audio;\n                this.audios[name].loaded = true;\n                resolve();\n            };\n            audio.onerror = () => {\n                throw new Error(`Error loading audio ${name}.`);\n            };\n            audio.src = audioPath;\n        });\n        return promise;\n    }\n    addLoadedSound({ name, audio }) {\n        if (this.audios.hasOwnProperty(name)) {\n            throw new Error(`Already loaded sound ${name}.`);\n        }\n        this.audios[name] = {\n            loaded: true,\n            audio,\n            loadPromise: Promise.resolve(),\n        };\n    }\n    playSound(name, { volume = 1 } = {}) {\n        if (this.muteState == MuteState.ALL_OFF) {\n            return;\n        }\n        const audio = this.audios[name].audio?.cloneNode();\n        if (audio == null) {\n            return;\n        }\n        // TODO: Adjust SFX volumes, probably just here.\n        audio.volume *= this.volume * volume;\n        audio.playbackRate = this.playbackRate;\n        // Disable type checking on these because typescript doesn't know about them yet.\n        audio.mozPreservesPitch = false;\n        audio.webkitPreservesPitch = false;\n        audio.preservesPitch = false;\n        const promise = audio.play();\n        // This may fail if the user hasn't interacted with the page yet.\n        // For these one-off sound effects, we don't need to do anything.\n        promise?.catch(() => { });\n    }\n    /** We still run the logic here when muted, so that we can update things when unmuted. */\n    async setSong(songName) {\n        if (this.curSongName == songName) {\n            return;\n        }\n        const lastSongName = this.curSongName;\n        const lastSong = this.curSong;\n        this.curSong?.pause();\n        this.curSong = undefined;\n        this.curSongName = undefined;\n        const audioInfo = this.audios[songName];\n        if (audioInfo == null) {\n            // Setting an invalid song name is a way to stop audio from playing.\n            return;\n        }\n        // Ensure the song is loaded\n        await audioInfo.loadPromise;\n        const audio = audioInfo.audio?.cloneNode();\n        if (audio == null) {\n            return;\n        }\n        audio.volume = this.volume * VOLUME_MULTIPLE;\n        audio.loop = true;\n        // Disable type checking on these because not typescript doesn't know about them yet.\n        audio.mozPreservesPitch = false;\n        audio.webkitPreservesPitch = false;\n        audio.preservesPitch = false;\n        if (lastSong != null) {\n            audio.playbackRate = lastSong.playbackRate;\n            if (lastSongName?.slice(0, 4) == songName.slice(0, 4)) {\n                audio.currentTime = lastSong.currentTime;\n            }\n        }\n        if (this.muteState == MuteState.PLAY_ALL) {\n            const promise = audio.play();\n            // This may fail if the user hasn't interacted with the page yet.\n            // We'll try to play it again when startSongIfNotAlreadyPlaying is\n            // called.\n            promise?.catch(() => { });\n        }\n        this.curSong = audio;\n        this.curSongName = songName;\n    }\n    setVolume(volume) {\n        this.volume = volume;\n        if (this.curSong != null) {\n            this.curSong.volume = this.volume * VOLUME_MULTIPLE;\n        }\n    }\n    updatePlaybackRate(desiredRate, dt) {\n        const updateAmt = 1 - Math.exp(-10 * dt);\n        this.playbackRate = lerp(this.playbackRate, desiredRate, updateAmt);\n        if (this.curSong != null) {\n            this.curSong.playbackRate = this.playbackRate;\n        }\n    }\n    loadMuteState() {\n        const storedMuteString = window.sessionStorage.getItem('mute') ?? \"\";\n        // Quick thing to make local dev default to music off.\n        if (storedMuteString == '' && window.location.href.includes('localhost')) {\n            console.log('Disabling music for local development');\n            this.muteState = MuteState.MUSIC_OFF;\n            return;\n        }\n        let muteState = parseInt(storedMuteString);\n        if (muteState != MuteState.PLAY_ALL &&\n            muteState != MuteState.MUSIC_OFF &&\n            muteState != MuteState.ALL_OFF) {\n            muteState = MuteState.PLAY_ALL;\n        }\n        this.muteState = muteState;\n    }\n    toggleMute() {\n        switch (this.muteState) {\n            case MuteState.PLAY_ALL:\n                this.muteState = MuteState.MUSIC_OFF;\n                break;\n            case MuteState.MUSIC_OFF:\n                this.muteState = MuteState.ALL_OFF;\n                break;\n            case MuteState.ALL_OFF:\n            default:\n                this.muteState = MuteState.PLAY_ALL;\n                break;\n        }\n        window.sessionStorage.setItem('mute', this.muteState.toString());\n        this.updateSoundMutedness();\n    }\n    updateSoundMutedness() {\n        switch (this.muteState) {\n            case MuteState.PLAY_ALL:\n                if (this.curSong?.paused) {\n                    const promise = this.curSong.play();\n                    // Again, ignore the possible failure.\n                    promise?.catch(() => { });\n                }\n                break;\n            case MuteState.MUSIC_OFF:\n            case MuteState.ALL_OFF:\n                this.curSong?.pause();\n                break;\n        }\n    }\n    startSongIfNotAlreadyPlaying() {\n        this.updateSoundMutedness();\n    }\n}\nexport const Sounds = new _Sounds();\n","export function easeInOut(t, amt = 2) {\n    let tPow = Math.pow(t, amt);\n    return tPow / (tPow + Math.pow(1 - t, amt));\n}\nexport function sinEaseInOut(t) {\n    return 0.5 - 0.5 * Math.cos(Math.PI * t);\n}\nexport function loop(t) {\n    return 0.5 - 0.5 * Math.cos(Math.PI * 2 * t);\n}\nexport function lerp(val1, val2, amt) {\n    return (val2 - val1) * amt + val1;\n}\n// An alias for older projects\nexport const slurp = lerp;\nexport function experp(val1, val2, amt) {\n    return Math.exp(slurp(Math.log(val1), Math.log(val2), amt));\n}\nexport function clampedSlurp(val1, val2, amt) {\n    if (amt < 0) {\n        return val1;\n    }\n    if (amt > 1) {\n        return val2;\n    }\n    return slurp(val1, val2, amt);\n}\nexport function clamp(amt, val1, val2) {\n    if (amt < val1) {\n        return val1;\n    }\n    if (amt > val2) {\n        return val2;\n    }\n    return amt;\n}\n/**\n * Inverse of lerp.\n *\n * Extracts a 0-1 interval from a section of a 0-1 interval\n *\n * For example, if min == 0.3 and max == 0.7, you get:\n *\n *           0.3  0.7\n *     t: 0 --+----+-- 1\n *           /      \\\n *          /        \\\n *         /          \\\n *     -> 0 ---------- 1\n *\n * Useful for making sub animations.\n *\n * Doesn't do any clamping, so you might want to clamp yourself.\n */\nexport function invLerp(t, min, max) {\n    return (t - min) / (max - min);\n}\nexport const splitInternal = invLerp;\n// Alias for older projects\nexport const divideInterval = splitInternal;\n/**\n * Like invLerp, but with clamping.\n */\nexport function clampInvLerp(t, min, max) {\n    return clamp(splitInternal(t, min, max), 0, 1);\n}\nexport const clampedSplitInternal = clampInvLerp;\nexport function rgb(r, g, b) {\n    return 'rgb(' + r + ',' + g + ',' + b + ')';\n}\nexport function gray(whiteAmt) {\n    whiteAmt = clamp(whiteAmt, 0, 1);\n    const whiteRgb = Math.floor(255 * whiteAmt);\n    return rgb(whiteRgb, whiteRgb, whiteRgb);\n}\n// Pseudo-random number generator functions\n// From stack overflow: https://stackoverflow.com/a/47593316\nfunction xmur3(str) {\n    for (var i = 0, h = 1779033703 ^ str.length; i < str.length; i++)\n        h = Math.imul(h ^ str.charCodeAt(i), 3432918353),\n            h = h << 13 | h >>> 19;\n    return function () {\n        h = Math.imul(h ^ h >>> 16, 2246822507);\n        h = Math.imul(h ^ h >>> 13, 3266489909);\n        return (h ^= h >>> 16) >>> 0;\n    };\n}\n// Just using a simple 32-bit random number generator, our numbers don't need to be too random.\nfunction mulberry32(a) {\n    return function () {\n        var t = a += 0x6D2B79F5;\n        t = Math.imul(t ^ t >>> 15, t | 1);\n        t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n        return ((t ^ t >>> 14) >>> 0) / 4294967296;\n    };\n}\n/**\n * @param {string} seed What ya seed it with.\n * @returns {function():number} A wonderful seeded random number generator.\n */\nexport function seededRandom(seed) {\n    const seedFn = xmur3(seed);\n    return mulberry32(seedFn());\n}\nexport function choose(arr, rng) {\n    const index = Math.floor(rng() * arr.length);\n    return arr[index];\n}\nexport function wait(seconds) {\n    return new Promise(resolve => setTimeout(resolve, seconds * 1000));\n}\n","/*\n * RIFFWAVE.js v0.03 - Audio encoder for HTML5 <audio> elements.\n * Copyleft 2011 by Pedro Ladaria <pedro.ladaria at Gmail dot com>\n *\n * Public Domain\n *\n * Changelog:\n *\n * 0.01 - First release\n * 0.02 - New faster base64 encoding\n * 0.03 - Support for 16bit samples\n *\n * Notes:\n *\n * 8 bit data is unsigned: 0..255\n * 16 bit data is signed: -32,768..32,767\n *\n */\nvar FastBase64 = {\n    chars: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    encLookup: [],\n    Init: function () {\n        for (var i = 0; i < 4096; i++) {\n            this.encLookup[i] = this.chars[i >> 6] + this.chars[i & 0x3F];\n        }\n    },\n    Encode: function (src) {\n        var len = src.length;\n        var dst = '';\n        var i = 0;\n        while (len > 2) {\n            var n = (src[i] << 16) | (src[i + 1] << 8) | src[i + 2];\n            dst += this.encLookup[n >> 12] + this.encLookup[n & 0xFFF];\n            len -= 3;\n            i += 3;\n        }\n        if (len > 0) {\n            var n1 = (src[i] & 0xFC) >> 2;\n            var n2 = (src[i] & 0x03) << 4;\n            if (len > 1)\n                n2 |= (src[++i] & 0xF0) >> 4;\n            dst += this.chars[n1];\n            dst += this.chars[n2];\n            if (len == 2) {\n                var n3 = (src[i++] & 0x0F) << 2;\n                n3 |= (src[i] & 0xC0) >> 6;\n                dst += this.chars[n3];\n            }\n            if (len == 1)\n                dst += '=';\n            dst += '=';\n        }\n        return dst;\n    } // end Encode\n};\nFastBase64.Init();\nexport const RIFFWAVE = function (data) {\n    this.data = []; // Array containing audio samples\n    this.wav = []; // Array containing the generated wave file\n    this.dataURI = ''; // http://en.wikipedia.org/wiki/Data_URI_scheme\n    this.header = {\n        chunkId: [0x52, 0x49, 0x46, 0x46], // 0    4    \"RIFF\" = 0x52494646\n        chunkSize: 0, // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)\n        format: [0x57, 0x41, 0x56, 0x45], // 8    4    \"WAVE\" = 0x57415645\n        subChunk1Id: [0x66, 0x6d, 0x74, 0x20], // 12   4    \"fmt \" = 0x666d7420\n        subChunk1Size: 16, // 16   4    16 for PCM\n        audioFormat: 1, // 20   2    PCM = 1\n        numChannels: 1, // 22   2    Mono = 1, Stereo = 2...\n        sampleRate: 8000, // 24   4    8000, 44100...\n        byteRate: 0, // 28   4    SampleRate*NumChannels*BitsPerSample/8\n        blockAlign: 0, // 32   2    NumChannels*BitsPerSample/8\n        bitsPerSample: 8, // 34   2    8 bits = 8, 16 bits = 16\n        subChunk2Id: [0x64, 0x61, 0x74, 0x61], // 36   4    \"data\" = 0x64617461\n        subChunk2Size: 0 // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8\n    };\n    function u32ToArray(i) {\n        return [i & 0xFF, (i >> 8) & 0xFF, (i >> 16) & 0xFF, (i >> 24) & 0xFF];\n    }\n    function u16ToArray(i) {\n        return [i & 0xFF, (i >> 8) & 0xFF];\n    }\n    function split16bitArray(data) {\n        var r = [];\n        var j = 0;\n        var len = data.length;\n        for (var i = 0; i < len; i++) {\n            r[j++] = data[i] & 0xFF;\n            r[j++] = (data[i] >> 8) & 0xFF;\n        }\n        return r;\n    }\n    this.Make = function (data) {\n        if (data instanceof Array)\n            this.data = data;\n        this.header.byteRate = (this.header.sampleRate * this.header.numChannels * this.header.bitsPerSample) >> 3;\n        this.header.blockAlign = (this.header.numChannels * this.header.bitsPerSample) >> 3;\n        this.header.subChunk2Size = this.data.length;\n        this.header.chunkSize = 36 + this.header.subChunk2Size;\n        this.wav = this.header.chunkId.concat(u32ToArray(this.header.chunkSize), this.header.format, this.header.subChunk1Id, u32ToArray(this.header.subChunk1Size), u16ToArray(this.header.audioFormat), u16ToArray(this.header.numChannels), u32ToArray(this.header.sampleRate), u32ToArray(this.header.byteRate), u16ToArray(this.header.blockAlign), u16ToArray(this.header.bitsPerSample), this.header.subChunk2Id, u32ToArray(this.header.subChunk2Size), this.data);\n        this.dataURI = 'data:audio/wav;base64,' + FastBase64.Encode(this.wav);\n    };\n    if (data instanceof Array)\n        this.Make(data);\n}; // end RIFFWAVE\n","import { RIFFWAVE } from \"./riffwave.js\";\n// Wave shapes\nvar SQUARE = 0;\nvar SAWTOOTH = 1;\nvar SINE = 2;\nvar NOISE = 3;\n// Playback volume\nvar masterVolume = 1;\nvar OVERSAMPLING = 8;\n/*** Core data structure ***/\n// Sound generation parameters are on [0,1] unless noted SIGNED & thus\n// on [-1,1]\nexport function Params() {\n    this.oldParams = true; // Note what structure this is\n    // Wave shape\n    this.wave_type = SQUARE;\n    // Envelope\n    this.p_env_attack = 0; // Attack time\n    this.p_env_sustain = 0.3; // Sustain time\n    this.p_env_punch = 0; // Sustain punch\n    this.p_env_decay = 0.4; // Decay time\n    // Tone\n    this.p_base_freq = 0.3; // Start frequency\n    this.p_freq_limit = 0; // Min frequency cutoff\n    this.p_freq_ramp = 0; // Slide (SIGNED)\n    this.p_freq_dramp = 0; // Delta slide (SIGNED)\n    // Vibrato\n    this.p_vib_strength = 0; // Vibrato depth\n    this.p_vib_speed = 0; // Vibrato speed\n    // Tonal change\n    this.p_arp_mod = 0; // Change amount (SIGNED)\n    this.p_arp_speed = 0; // Change speed\n    // Square wave duty (proportion of time signal is high vs. low)\n    this.p_duty = 0; // Square duty\n    this.p_duty_ramp = 0; // Duty sweep (SIGNED)\n    // Repeat\n    this.p_repeat_speed = 0; // Repeat speed\n    // Flanger\n    this.p_pha_offset = 0; // Flanger offset (SIGNED)\n    this.p_pha_ramp = 0; // Flanger sweep (SIGNED)\n    // Low-pass filter\n    this.p_lpf_freq = 1; // Low-pass filter cutoff\n    this.p_lpf_ramp = 0; // Low-pass filter cutoff sweep (SIGNED)\n    this.p_lpf_resonance = 0; // Low-pass filter resonance\n    // High-pass filter\n    this.p_hpf_freq = 0; // High-pass filter cutoff\n    this.p_hpf_ramp = 0; // High-pass filter cutoff sweep (SIGNED)\n    // Sample parameters\n    this.sound_vol = 0.5;\n    this.sample_rate = 44100;\n    this.sample_size = 8;\n}\n/*** Helper functions ***/\nfunction sqr(x) { return x * x; }\nfunction cube(x) { return x * x * x; }\nfunction sign(x) { return x < 0 ? -1 : 1; }\nfunction log(x, b) { return Math.log(x) / Math.log(b); }\nvar pow = Math.pow;\nfunction frnd(range) {\n    return Math.random() * range;\n}\nfunction rndr(from, to) {\n    return Math.random() * (to - from) + from;\n}\nfunction rnd(max) {\n    return Math.floor(Math.random() * (max + 1));\n}\n/*** Import/export functions ***/\n// http://stackoverflow.com/questions/3096646/how-to-convert-a-floating-point-number-to-its-binary-representation-ieee-754-i\nfunction assembleFloat(sign, exponent, mantissa) {\n    return (sign << 31) | (exponent << 23) | (mantissa);\n}\nfunction floatToNumber(flt) {\n    if (isNaN(flt)) // Special case: NaN\n        return assembleFloat(0, 0xFF, 0x1337); // Mantissa is nonzero for NaN\n    var sign = (flt < 0) ? 1 : 0;\n    flt = Math.abs(flt);\n    if (flt == 0.0) // Special case: +-0\n        return assembleFloat(sign, 0, 0);\n    var exponent = Math.floor(Math.log(flt) / Math.LN2);\n    if (exponent > 127 || exponent < -126) // Special case: +-Infinity (and huge numbers)\n        return assembleFloat(sign, 0xFF, 0); // Mantissa is zero for +-Infinity\n    var mantissa = flt / Math.pow(2, exponent);\n    return assembleFloat(sign, exponent + 127, (mantissa * Math.pow(2, 23)) & 0x7FFFFF);\n}\n// http://stackoverflow.com/a/16001019\nfunction numberToFloat(bytes) {\n    var sign = (bytes & 0x80000000) ? -1 : 1;\n    var exponent = ((bytes >> 23) & 0xFF) - 127;\n    var significand = (bytes & ~(-1 << 23));\n    if (exponent == 128)\n        return sign * ((significand) ? Number.NaN : Number.POSITIVE_INFINITY);\n    if (exponent == -127) {\n        if (significand == 0)\n            return sign * 0.0;\n        exponent = -126;\n        significand /= (1 << 22);\n    }\n    else\n        significand = (significand | (1 << 23)) / (1 << 23);\n    return sign * significand * Math.pow(2, exponent);\n}\n// export parameter list to URL friendly base58 string\n// https://gist.github.com/diafygi/90a3e80ca1c2793220e5/\nvar b58alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar params_order = [\n    \"wave_type\",\n    \"p_env_attack\",\n    \"p_env_sustain\",\n    \"p_env_punch\",\n    \"p_env_decay\",\n    \"p_base_freq\",\n    \"p_freq_limit\",\n    \"p_freq_ramp\",\n    \"p_freq_dramp\",\n    \"p_vib_strength\",\n    \"p_vib_speed\",\n    \"p_arp_mod\",\n    \"p_arp_speed\",\n    \"p_duty\",\n    \"p_duty_ramp\",\n    \"p_repeat_speed\",\n    \"p_pha_offset\",\n    \"p_pha_ramp\",\n    \"p_lpf_freq\",\n    \"p_lpf_ramp\",\n    \"p_lpf_resonance\",\n    \"p_hpf_freq\",\n    \"p_hpf_ramp\"\n];\nvar params_signed = [\"p_freq_ramp\", \"p_freq_dramp\", \"p_arp_mod\", \"p_duty_ramp\", \"p_pha_offset\", \"p_pha_ramp\", \"p_lpf_ramp\", \"p_hpf_ramp\"];\nParams.prototype.toB58 = function () {\n    var convert = [];\n    for (var pi in params_order) {\n        var p = params_order[pi];\n        if (p == \"wave_type\") {\n            convert.push(this[p]);\n        }\n        else if (p.indexOf(\"p_\") == 0) {\n            var val = this[p];\n            val = floatToNumber(val);\n            convert.push(0xff & val);\n            convert.push(0xff & (val >> 8));\n            convert.push(0xff & (val >> 16));\n            convert.push(0xff & (val >> 24));\n        }\n    }\n    return function (B, A) { var d = [], s = \"\", i, j, c, n; for (i in B) {\n        j = 0, c = B[i];\n        s += c || s.length ^ i ? \"\" : 1;\n        while (j in d || c) {\n            n = d[j];\n            n = n ? n * 256 + c : c;\n            c = n / 58 | 0;\n            d[j] = n % 58;\n            j++;\n        }\n    } while (j--)\n        s += A[d[j]]; return s; }(convert, b58alphabet);\n};\nParams.prototype.fromB58 = function (b58encoded) {\n    this.fromJSON(sfxr.b58decode(b58encoded));\n    return this;\n};\nParams.prototype.fromJSON = function (struct) {\n    for (var p in struct) {\n        if (struct.hasOwnProperty(p)) {\n            this[p] = struct[p];\n        }\n    }\n    return this;\n};\n/*** Presets ***/\n// These functions roll up random sounds appropriate to various\n// typical game events:\nParams.prototype.pickupCoin = function () {\n    this.wave_type = SAWTOOTH;\n    this.p_base_freq = 0.4 + frnd(0.5);\n    this.p_env_attack = 0;\n    this.p_env_sustain = frnd(0.1);\n    this.p_env_decay = 0.1 + frnd(0.4);\n    this.p_env_punch = 0.3 + frnd(0.3);\n    if (rnd(1)) {\n        this.p_arp_speed = 0.5 + frnd(0.2);\n        this.p_arp_mod = 0.2 + frnd(0.4);\n    }\n    return this;\n};\nParams.prototype.laserShoot = function () {\n    this.wave_type = rnd(2);\n    if (this.wave_type === SINE && rnd(1))\n        this.wave_type = rnd(1);\n    if (rnd(2) === 0) {\n        this.p_base_freq = 0.3 + frnd(0.6);\n        this.p_freq_limit = frnd(0.1);\n        this.p_freq_ramp = -0.35 - frnd(0.3);\n    }\n    else {\n        this.p_base_freq = 0.5 + frnd(0.5);\n        this.p_freq_limit = this.p_base_freq - 0.2 - frnd(0.6);\n        if (this.p_freq_limit < 0.2)\n            this.p_freq_limit = 0.2;\n        this.p_freq_ramp = -0.15 - frnd(0.2);\n    }\n    if (this.wave_type === SAWTOOTH)\n        this.p_duty = 1;\n    if (rnd(1)) {\n        this.p_duty = frnd(0.5);\n        this.p_duty_ramp = frnd(0.2);\n    }\n    else {\n        this.p_duty = 0.4 + frnd(0.5);\n        this.p_duty_ramp = -frnd(0.7);\n    }\n    this.p_env_attack = 0;\n    this.p_env_sustain = 0.1 + frnd(0.2);\n    this.p_env_decay = frnd(0.4);\n    if (rnd(1))\n        this.p_env_punch = frnd(0.3);\n    if (rnd(2) === 0) {\n        this.p_pha_offset = frnd(0.2);\n        this.p_pha_ramp = -frnd(0.2);\n    }\n    //if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n    return this;\n};\nParams.prototype.explosion = function () {\n    this.wave_type = NOISE;\n    if (rnd(1)) {\n        this.p_base_freq = sqr(0.1 + frnd(0.4));\n        this.p_freq_ramp = -0.1 + frnd(0.4);\n    }\n    else {\n        this.p_base_freq = sqr(0.2 + frnd(0.7));\n        this.p_freq_ramp = -0.2 - frnd(0.2);\n    }\n    if (rnd(4) === 0)\n        this.p_freq_ramp = 0;\n    if (rnd(2) === 0)\n        this.p_repeat_speed = 0.3 + frnd(0.5);\n    this.p_env_attack = 0;\n    this.p_env_sustain = 0.1 + frnd(0.3);\n    this.p_env_decay = frnd(0.5);\n    if (rnd(1)) {\n        this.p_pha_offset = -0.3 + frnd(0.9);\n        this.p_pha_ramp = -frnd(0.3);\n    }\n    this.p_env_punch = 0.2 + frnd(0.6);\n    if (rnd(1)) {\n        this.p_vib_strength = frnd(0.7);\n        this.p_vib_speed = frnd(0.6);\n    }\n    if (rnd(2) === 0) {\n        this.p_arp_speed = 0.6 + frnd(0.3);\n        this.p_arp_mod = 0.8 - frnd(1.6);\n    }\n    return this;\n};\nParams.prototype.powerUp = function () {\n    if (rnd(1)) {\n        this.wave_type = SAWTOOTH;\n        this.p_duty = 1;\n    }\n    else {\n        this.p_duty = frnd(0.6);\n    }\n    this.p_base_freq = 0.2 + frnd(0.3);\n    if (rnd(1)) {\n        this.p_freq_ramp = 0.1 + frnd(0.4);\n        this.p_repeat_speed = 0.4 + frnd(0.4);\n    }\n    else {\n        this.p_freq_ramp = 0.05 + frnd(0.2);\n        if (rnd(1)) {\n            this.p_vib_strength = frnd(0.7);\n            this.p_vib_speed = frnd(0.6);\n        }\n    }\n    this.p_env_attack = 0;\n    this.p_env_sustain = frnd(0.4);\n    this.p_env_decay = 0.1 + frnd(0.4);\n    return this;\n};\nParams.prototype.hitHurt = function () {\n    this.wave_type = rnd(2);\n    if (this.wave_type === SINE)\n        this.wave_type = NOISE;\n    if (this.wave_type === SQUARE)\n        this.p_duty = frnd(0.6);\n    if (this.wave_type === SAWTOOTH)\n        this.p_duty = 1;\n    this.p_base_freq = 0.2 + frnd(0.6);\n    this.p_freq_ramp = -0.3 - frnd(0.4);\n    this.p_env_attack = 0;\n    this.p_env_sustain = frnd(0.1);\n    this.p_env_decay = 0.1 + frnd(0.2);\n    if (rnd(1))\n        this.p_hpf_freq = frnd(0.3);\n    return this;\n};\nParams.prototype.jump = function () {\n    this.wave_type = SQUARE;\n    this.p_duty = frnd(0.6);\n    this.p_base_freq = 0.3 + frnd(0.3);\n    this.p_freq_ramp = 0.1 + frnd(0.2);\n    this.p_env_attack = 0;\n    this.p_env_sustain = 0.1 + frnd(0.3);\n    this.p_env_decay = 0.1 + frnd(0.2);\n    if (rnd(1))\n        this.p_hpf_freq = frnd(0.3);\n    if (rnd(1))\n        this.p_lpf_freq = 1 - frnd(0.6);\n    return this;\n};\nParams.prototype.blipSelect = function () {\n    this.wave_type = rnd(1);\n    if (this.wave_type === SQUARE)\n        this.p_duty = frnd(0.6);\n    else\n        this.p_duty = 1;\n    this.p_base_freq = 0.2 + frnd(0.4);\n    this.p_env_attack = 0;\n    this.p_env_sustain = 0.1 + frnd(0.1);\n    this.p_env_decay = frnd(0.2);\n    this.p_hpf_freq = 0.1;\n    return this;\n};\nParams.prototype.synth = function () {\n    this.wave_type = rnd(1);\n    this.p_base_freq = [0.2723171360931539, 0.19255692561524382, 0.13615778746815113][rnd(2)];\n    this.p_env_attack = rnd(4) > 3 ? frnd(0.5) : 0;\n    this.p_env_sustain = frnd(1);\n    this.p_env_punch = frnd(1);\n    this.p_env_decay = frnd(0.9) + 0.1;\n    this.p_arp_mod = [0, 0, 0, 0, -0.3162, 0.7454, 0.7454][rnd(6)];\n    this.p_arp_speed = frnd(0.5) + 0.4;\n    this.p_duty = frnd(1);\n    this.p_duty_ramp = rnd(2) == 2 ? frnd(1) : 0;\n    this.p_lpf_freq = [1, 0.9 * frnd(1) * frnd(1) + 0.1][rnd(1)];\n    this.p_lpf_ramp = rndr(-1, 1);\n    this.p_lpf_resonance = frnd(1);\n    this.p_hpf_freq = rnd(3) == 3 ? frnd(1) : 0;\n    this.p_hpf_ramp = rnd(3) == 3 ? frnd(1) : 0;\n    return this;\n};\nParams.prototype.tone = function () {\n    this.wave_type = SINE;\n    this.p_base_freq = 0.35173364; // 440 Hz\n    this.p_env_attack = 0;\n    this.p_env_sustain = 0.6641; // 1 sec\n    this.p_env_decay = 0;\n    this.p_env_punch = 0;\n    return this;\n};\nParams.prototype.click = function () {\n    const base = [\"explosion\", \"hitHurt\"][rnd(1)];\n    this[base]();\n    if (rnd(1)) {\n        this.p_freq_ramp = -0.5 + frnd(1.0);\n    }\n    if (rnd(1)) {\n        this.p_env_sustain = (frnd(0.4) + 0.2) * this.p_env_sustain;\n        this.p_env_decay = (frnd(0.4) + 0.2) * this.p_env_decay;\n    }\n    if (rnd(3) == 0) {\n        this.p_env_attack = frnd(0.3);\n    }\n    this.p_base_freq = 1 - frnd(0.25);\n    this.p_hpf_freq = 1 - frnd(0.1);\n    return this;\n};\nParams.prototype.random = function () {\n    this.wave_type = rnd(3);\n    if (rnd(1))\n        this.p_base_freq = cube(frnd(2) - 1) + 0.5;\n    else\n        this.p_base_freq = sqr(frnd(1));\n    this.p_freq_limit = 0;\n    this.p_freq_ramp = Math.pow(frnd(2) - 1, 5);\n    if (this.p_base_freq > 0.7 && this.p_freq_ramp > 0.2)\n        this.p_freq_ramp = -this.p_freq_ramp;\n    if (this.p_base_freq < 0.2 && this.p_freq_ramp < -0.05)\n        this.p_freq_ramp = -this.p_freq_ramp;\n    this.p_freq_dramp = Math.pow(frnd(2) - 1, 3);\n    this.p_duty = frnd(2) - 1;\n    this.p_duty_ramp = Math.pow(frnd(2) - 1, 3);\n    this.p_vib_strength = Math.pow(frnd(2) - 1, 3);\n    this.p_vib_speed = rndr(-1, 1);\n    this.p_env_attack = cube(rndr(-1, 1));\n    this.p_env_sustain = sqr(rndr(-1, 1));\n    this.p_env_decay = rndr(-1, 1);\n    this.p_env_punch = Math.pow(frnd(0.8), 2);\n    if (this.p_env_attack + this.p_env_sustain + this.p_env_decay < 0.2) {\n        this.p_env_sustain += 0.2 + frnd(0.3);\n        this.p_env_decay += 0.2 + frnd(0.3);\n    }\n    this.p_lpf_resonance = rndr(-1, 1);\n    this.p_lpf_freq = 1 - Math.pow(frnd(1), 3);\n    this.p_lpf_ramp = Math.pow(frnd(2) - 1, 3);\n    if (this.p_lpf_freq < 0.1 && this.p_lpf_ramp < -0.05)\n        this.p_lpf_ramp = -this.p_lpf_ramp;\n    this.p_hpf_freq = Math.pow(frnd(1), 5);\n    this.p_hpf_ramp = Math.pow(frnd(2) - 1, 5);\n    this.p_pha_offset = Math.pow(frnd(2) - 1, 3);\n    this.p_pha_ramp = Math.pow(frnd(2) - 1, 3);\n    this.p_repeat_speed = frnd(2) - 1;\n    this.p_arp_speed = frnd(2) - 1;\n    this.p_arp_mod = frnd(2) - 1;\n    return this;\n};\nParams.prototype.mutate = function () {\n    if (rnd(1))\n        this.p_base_freq += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_freq_ramp += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_freq_dramp += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_duty += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_duty_ramp += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_vib_strength += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_vib_speed += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_vib_delay += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_env_attack += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_env_sustain += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_env_decay += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_env_punch += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_lpf_resonance += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_lpf_freq += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_lpf_ramp += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_hpf_freq += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_hpf_ramp += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_pha_offset += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_pha_ramp += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_repeat_speed += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_arp_speed += frnd(0.1) - 0.05;\n    if (rnd(1))\n        this.p_arp_mod += frnd(0.1) - 0.05;\n    return this;\n};\n/*** Simpler namespaced functional API ***/\nexport const sfxr = {};\nsfxr.toBuffer = function (synthdef) {\n    return (new SoundEffect(synthdef)).getRawBuffer()[\"buffer\"];\n};\nsfxr.toWebAudio = function (synthdef, audiocontext) {\n    var sfx = new SoundEffect(synthdef);\n    var buffer = sfx.getRawBuffer()[\"normalized\"];\n    if (audiocontext) {\n        var buff = audiocontext.createBuffer(1, buffer.length, sfx.sampleRate);\n        var nowBuffering = buff.getChannelData(0);\n        for (var i = 0; i < buffer.length; i++) {\n            nowBuffering[i] = buffer[i];\n        }\n        var proc = audiocontext.createBufferSource();\n        proc.buffer = buff;\n        return proc;\n    }\n};\nsfxr.toWave = function (synthdef) {\n    return (new SoundEffect(synthdef)).generate();\n};\nsfxr.toAudio = function (synthdef) {\n    return sfxr.toWave(synthdef).getAudio();\n};\nsfxr.play = function (synthdef) {\n    return sfxr.toAudio(synthdef).play();\n};\nsfxr.b58decode = function (b58encoded) {\n    var decoded = function (S, A) { var d = [], b = [], i, j, c, n; for (i in S) {\n        j = 0, c = A.indexOf(S[i]);\n        if (c < 0)\n            return undefined;\n        c || b.length ^ i ? i : b.push(0);\n        while (j in d || c) {\n            n = d[j];\n            n = n ? n * 58 + c : c;\n            c = n >> 8;\n            d[j] = n % 256;\n            j++;\n        }\n    } while (j--)\n        b.push(d[j]); return new Uint8Array(b); }(b58encoded, b58alphabet);\n    var result = {};\n    for (var pi in params_order) {\n        var p = params_order[pi];\n        var offset = (pi - 1) * 4 + 1;\n        if (p == \"wave_type\") {\n            result[p] = decoded[0];\n        }\n        else {\n            var val = (decoded[offset] | (decoded[offset + 1] << 8) | (decoded[offset + 2] << 16) | (decoded[offset + 3] << 24));\n            result[p] = numberToFloat(val);\n        }\n    }\n    return result;\n};\nsfxr.b58encode = function (synthdef) {\n    var p = new Params();\n    p.fromJSON(synthdef);\n    return p.toB58();\n};\nsfxr.generate = function (algorithm, options) {\n    const p = new Params();\n    const opts = options || {};\n    p.sound_vol = opts[\"sound_vol\"] || 0.25;\n    p.sample_rate = opts[\"sample_rate\"] || 44100;\n    p.sample_size = opts[\"sample_size\"] || 8;\n    return p[algorithm]();\n};\n/*** Main entry point ***/\nexport function SoundEffect(ps) {\n    if (typeof (ps) == \"string\") {\n        var PARAMS = new Params();\n        if (ps.indexOf(\"#\") == 0) {\n            ps = ps.slice(1);\n        }\n        ps = PARAMS.fromB58(ps);\n    }\n    this.init(ps);\n}\nSoundEffect.prototype.init = function (ps) {\n    this.parameters = ps;\n    this.initForRepeat(); // First time through, this is a bit of a misnomer\n    // Waveform shape\n    this.waveShape = parseInt(ps.wave_type);\n    // Filter\n    this.fltw = Math.pow(ps.p_lpf_freq, 3) * 0.1;\n    this.enableLowPassFilter = (ps.p_lpf_freq != 1);\n    this.fltw_d = 1 + ps.p_lpf_ramp * 0.0001;\n    this.fltdmp = 5 / (1 + Math.pow(ps.p_lpf_resonance, 2) * 20) *\n        (0.01 + this.fltw);\n    if (this.fltdmp > 0.8)\n        this.fltdmp = 0.8;\n    this.flthp = Math.pow(ps.p_hpf_freq, 2) * 0.1;\n    this.flthp_d = 1 + ps.p_hpf_ramp * 0.0003;\n    // Vibrato\n    this.vibratoSpeed = Math.pow(ps.p_vib_speed, 2) * 0.01;\n    this.vibratoAmplitude = ps.p_vib_strength * 0.5;\n    // Envelope\n    this.envelopeLength = [\n        Math.floor(ps.p_env_attack * ps.p_env_attack * 100000),\n        Math.floor(ps.p_env_sustain * ps.p_env_sustain * 100000),\n        Math.floor(ps.p_env_decay * ps.p_env_decay * 100000)\n    ];\n    this.envelopePunch = ps.p_env_punch;\n    // Flanger\n    this.flangerOffset = Math.pow(ps.p_pha_offset, 2) * 1020;\n    if (ps.p_pha_offset < 0)\n        this.flangerOffset = -this.flangerOffset;\n    this.flangerOffsetSlide = Math.pow(ps.p_pha_ramp, 2) * 1;\n    if (ps.p_pha_ramp < 0)\n        this.flangerOffsetSlide = -this.flangerOffsetSlide;\n    // Repeat\n    this.repeatTime = Math.floor(Math.pow(1 - ps.p_repeat_speed, 2) * 20000\n        + 32);\n    if (ps.p_repeat_speed === 0)\n        this.repeatTime = 0;\n    this.gain = Math.exp(ps.sound_vol) - 1;\n    this.sampleRate = ps.sample_rate;\n    this.bitsPerChannel = ps.sample_size;\n};\nSoundEffect.prototype.initForRepeat = function () {\n    var ps = this.parameters;\n    this.elapsedSinceRepeat = 0;\n    this.period = 100 / (ps.p_base_freq * ps.p_base_freq + 0.001);\n    this.periodMax = 100 / (ps.p_freq_limit * ps.p_freq_limit + 0.001);\n    this.enableFrequencyCutoff = (ps.p_freq_limit > 0);\n    this.periodMult = 1 - Math.pow(ps.p_freq_ramp, 3) * 0.01;\n    this.periodMultSlide = -Math.pow(ps.p_freq_dramp, 3) * 0.000001;\n    this.dutyCycle = 0.5 - ps.p_duty * 0.5;\n    this.dutyCycleSlide = -ps.p_duty_ramp * 0.00005;\n    if (ps.p_arp_mod >= 0)\n        this.arpeggioMultiplier = 1 - Math.pow(ps.p_arp_mod, 2) * .9;\n    else\n        this.arpeggioMultiplier = 1 + Math.pow(ps.p_arp_mod, 2) * 10;\n    this.arpeggioTime = Math.floor(Math.pow(1 - ps.p_arp_speed, 2) * 20000 + 32);\n    if (ps.p_arp_speed === 1)\n        this.arpeggioTime = 0;\n};\nSoundEffect.prototype.getRawBuffer = function () {\n    var fltp = 0;\n    var fltdp = 0;\n    var fltphp = 0;\n    var noise_buffer = Array(32);\n    for (var i = 0; i < 32; ++i)\n        noise_buffer[i] = Math.random() * 2 - 1;\n    var envelopeStage = 0;\n    var envelopeElapsed = 0;\n    var vibratoPhase = 0;\n    var phase = 0;\n    var ipp = 0;\n    var flanger_buffer = Array(1024);\n    for (var i = 0; i < 1024; ++i)\n        flanger_buffer[i] = 0;\n    var num_clipped = 0;\n    var buffer = [];\n    var normalized = [];\n    var sample_sum = 0;\n    var num_summed = 0;\n    var summands = Math.floor(44100 / this.sampleRate);\n    for (var t = 0;; ++t) {\n        // Repeats\n        if (this.repeatTime != 0 && ++this.elapsedSinceRepeat >= this.repeatTime)\n            this.initForRepeat();\n        // Arpeggio (single)\n        if (this.arpeggioTime != 0 && t >= this.arpeggioTime) {\n            this.arpeggioTime = 0;\n            this.period *= this.arpeggioMultiplier;\n        }\n        // Frequency slide, and frequency slide slide!\n        this.periodMult += this.periodMultSlide;\n        this.period *= this.periodMult;\n        if (this.period > this.periodMax) {\n            this.period = this.periodMax;\n            if (this.enableFrequencyCutoff)\n                break;\n        }\n        // Vibrato\n        var rfperiod = this.period;\n        if (this.vibratoAmplitude > 0) {\n            vibratoPhase += this.vibratoSpeed;\n            rfperiod = this.period * (1 + Math.sin(vibratoPhase) * this.vibratoAmplitude);\n        }\n        var iperiod = Math.floor(rfperiod);\n        if (iperiod < OVERSAMPLING)\n            iperiod = OVERSAMPLING;\n        // Square wave duty cycle\n        this.dutyCycle += this.dutyCycleSlide;\n        if (this.dutyCycle < 0)\n            this.dutyCycle = 0;\n        if (this.dutyCycle > 0.5)\n            this.dutyCycle = 0.5;\n        // Volume envelope\n        if (++envelopeElapsed > this.envelopeLength[envelopeStage]) {\n            envelopeElapsed = 0;\n            if (++envelopeStage > 2)\n                break;\n        }\n        var env_vol;\n        var envf = envelopeElapsed / this.envelopeLength[envelopeStage];\n        if (envelopeStage === 0) { // Attack\n            env_vol = envf;\n        }\n        else if (envelopeStage === 1) { // Sustain\n            env_vol = 1 + (1 - envf) * 2 * this.envelopePunch;\n        }\n        else { // Decay\n            env_vol = 1 - envf;\n        }\n        // Flanger step\n        this.flangerOffset += this.flangerOffsetSlide;\n        var iphase = Math.abs(Math.floor(this.flangerOffset));\n        if (iphase > 1023)\n            iphase = 1023;\n        if (this.flthp_d != 0) {\n            this.flthp *= this.flthp_d;\n            if (this.flthp < 0.00001)\n                this.flthp = 0.00001;\n            if (this.flthp > 0.1)\n                this.flthp = 0.1;\n        }\n        // 8x oversampling\n        var sample = 0;\n        for (var si = 0; si < OVERSAMPLING; ++si) {\n            var sub_sample = 0;\n            phase++;\n            if (phase >= iperiod) {\n                phase %= iperiod;\n                if (this.waveShape === NOISE)\n                    for (var i = 0; i < 32; ++i)\n                        noise_buffer[i] = Math.random() * 2 - 1;\n            }\n            // Base waveform\n            var fp = phase / iperiod;\n            if (this.waveShape === SQUARE) {\n                if (fp < this.dutyCycle)\n                    sub_sample = 0.5;\n                else\n                    sub_sample = -0.5;\n            }\n            else if (this.waveShape === SAWTOOTH) {\n                if (fp < this.dutyCycle)\n                    sub_sample = -1 + 2 * fp / this.dutyCycle;\n                else\n                    sub_sample = 1 - 2 * (fp - this.dutyCycle) / (1 - this.dutyCycle);\n            }\n            else if (this.waveShape === SINE) {\n                sub_sample = Math.sin(fp * 2 * Math.PI);\n            }\n            else if (this.waveShape === NOISE) {\n                sub_sample = noise_buffer[Math.floor(phase * 32 / iperiod)];\n            }\n            else {\n                throw \"ERROR: Bad wave type: \" + this.waveShape;\n            }\n            // Low-pass filter\n            var pp = fltp;\n            this.fltw *= this.fltw_d;\n            if (this.fltw < 0)\n                this.fltw = 0;\n            if (this.fltw > 0.1)\n                this.fltw = 0.1;\n            if (this.enableLowPassFilter) {\n                fltdp += (sub_sample - fltp) * this.fltw;\n                fltdp -= fltdp * this.fltdmp;\n            }\n            else {\n                fltp = sub_sample;\n                fltdp = 0;\n            }\n            fltp += fltdp;\n            // High-pass filter\n            fltphp += fltp - pp;\n            fltphp -= fltphp * this.flthp;\n            sub_sample = fltphp;\n            // Flanger\n            flanger_buffer[ipp & 1023] = sub_sample;\n            sub_sample += flanger_buffer[(ipp - iphase + 1024) & 1023];\n            ipp = (ipp + 1) & 1023;\n            // final accumulation and envelope application\n            sample += sub_sample * env_vol;\n        }\n        // Accumulate samples appropriately for sample rate\n        sample_sum += sample;\n        if (++num_summed >= summands) {\n            num_summed = 0;\n            sample = sample_sum / summands;\n            sample_sum = 0;\n        }\n        else {\n            continue;\n        }\n        sample = sample / OVERSAMPLING * masterVolume;\n        sample *= this.gain;\n        // store the original normalized floating point sample\n        normalized.push(sample);\n        if (this.bitsPerChannel === 8) {\n            // Rescale [-1, 1) to [0, 256)\n            sample = Math.floor((sample + 1) * 128);\n            if (sample > 255) {\n                sample = 255;\n                ++num_clipped;\n            }\n            else if (sample < 0) {\n                sample = 0;\n                ++num_clipped;\n            }\n            buffer.push(sample);\n        }\n        else {\n            // Rescale [-1, 1) to [-32768, 32768)\n            sample = Math.floor(sample * (1 << 15));\n            if (sample >= (1 << 15)) {\n                sample = (1 << 15) - 1;\n                ++num_clipped;\n            }\n            else if (sample < -(1 << 15)) {\n                sample = -(1 << 15);\n                ++num_clipped;\n            }\n            buffer.push(sample & 0xFF);\n            buffer.push((sample >> 8) & 0xFF);\n        }\n    }\n    return {\n        \"buffer\": buffer,\n        \"normalized\": normalized,\n        \"clipped\": num_clipped,\n    };\n};\nSoundEffect.prototype.generate = function () {\n    var rendered = this.getRawBuffer();\n    var wave = new RIFFWAVE();\n    wave.header.sampleRate = this.sampleRate;\n    wave.header.bitsPerSample = this.bitsPerChannel;\n    wave.Make(rendered.buffer);\n    wave.clipping = rendered.clipped;\n    wave.buffer = rendered.normalized;\n    wave.getAudio = _sfxr_getAudioFn(wave);\n    return wave;\n};\nvar _actx = null;\nvar _sfxr_getAudioFn = function (wave) {\n    return function () {\n        // check for procedural audio\n        var actx = null;\n        if (!_actx) {\n            if ('AudioContext' in window) {\n                _actx = new AudioContext();\n            }\n            else if ('webkitAudioContext' in window) {\n                _actx = new webkitAudioContext();\n            }\n        }\n        actx = _actx;\n        if (actx) {\n            var buff = actx.createBuffer(1, wave.buffer.length, wave.header.sampleRate);\n            var nowBuffering = buff.getChannelData(0);\n            for (var i = 0; i < wave.buffer.length; i++) {\n                nowBuffering[i] = wave.buffer[i];\n            }\n            var volume = 1.0;\n            var obj = {\n                \"channels\": [],\n                \"setVolume\": function (v) { volume = v; return obj; },\n                \"play\": function () {\n                    var proc = actx.createBufferSource();\n                    proc.buffer = buff;\n                    var gainNode = actx.createGain();\n                    gainNode.gain.value = volume;\n                    gainNode.connect(actx.destination);\n                    proc.connect(gainNode);\n                    if (proc[\"start\"]) {\n                        proc.start();\n                    }\n                    else if (proc[\"noteOn\"]) {\n                        proc.noteOn(0);\n                    }\n                    this.channels.push(proc);\n                    return proc;\n                }\n            };\n            return obj;\n        }\n        else {\n            var audio = new Audio();\n            audio.src = wave.dataURI;\n            return audio;\n        }\n    };\n};\n/*** conversions from slider values, internal, and units ***/\n// convert from slider values to internal representation\nvar sliders = {\n    p_env_attack: function (v) { return v * v * 100000.0; },\n    p_env_sustain: function (v) { return v * v * 100000.0; },\n    p_env_punch: function (v) { return v; },\n    p_env_decay: function (v) { return v * v * 100000.0; },\n    p_base_freq: function (v) { return 8 * 44100 * (v * v + 0.001) / 100; },\n    p_freq_limit: function (v) { return 8 * 44100 * (v * v + 0.001) / 100; },\n    p_freq_ramp: function (v) { return 1.0 - Math.pow(v, 3.0) * 0.01; },\n    p_freq_dramp: function (v) { return -Math.pow(v, 3.0) * 0.000001; },\n    p_vib_speed: function (v) { return Math.pow(v, 2.0) * 0.01; },\n    p_vib_strength: function (v) { return v * 0.5; },\n    p_arp_mod: function (v) {\n        return v >= 0 ? 1.0 - Math.pow(v, 2) * 0.9 : 1.0 + Math.pow(v, 2) * 10;\n    },\n    p_arp_speed: function (v) {\n        return (v === 1.0) ? 0 :\n            Math.floor(Math.pow(1.0 - v, 2.0) * 20000 + 32);\n    },\n    p_duty: function (v) { return 0.5 - v * 0.5; },\n    p_duty_ramp: function (v) { return -v * 0.00005; },\n    p_repeat_speed: function (v) {\n        return (v === 0) ? 0 :\n            Math.floor(Math.pow(1 - v, 2) * 20000) + 32;\n    },\n    p_pha_offset: function (v) { return (v < 0 ? -1 : 1) * Math.pow(v, 2) * 1020; },\n    p_pha_ramp: function (v) { return (v < 0 ? -1 : 1) * Math.pow(v, 2); },\n    p_lpf_freq: function (v) { return Math.pow(v, 3) * 0.1; },\n    p_lpf_ramp: function (v) { return 1.0 + v * 0.0001; },\n    p_lpf_resonance: function (v) { return 5.0 / (1.0 + Math.pow(v, 2) * 20); }, // * (0.01 + fltw);\n    p_hpf_freq: function (v) { return Math.pow(v, 2) * 0.1; },\n    p_hpf_ramp: function (v) { return 1.0 + v * 0.0003; },\n    sound_vol: function (v) { return Math.exp(v) - 1; }\n};\nvar sliders_inverse = {\n    p_env_attack: function (v) { return Math.sqrt(v / 100000.0); },\n    p_env_sustain: function (v) { return Math.sqrt(v / 100000.0); },\n    p_env_punch: function (v) { return v; },\n    p_env_decay: function (v) { return Math.sqrt(v / 100000.0); },\n    p_base_freq: function (v) { return Math.sqrt(v * 100 / 8 / 44100 - 0.001); },\n    p_freq_limit: function (v) { return Math.sqrt(v * 100 / 8 / 44100 - 0.001); },\n    p_freq_ramp: function (v) { return Math.cbrt((1.0 - v) / 0.01); },\n    p_freq_dramp: function (v) { return Math.cbrt(v / -0.000001); },\n    p_vib_speed: function (v) { return Math.sqrt(v / 0.01); },\n    p_vib_strength: function (v) { return v / 0.5; },\n    p_arp_mod: function (v) {\n        return v < 1 ? Math.sqrt((1.0 - v) / 0.9) : -Math.sqrt((v - 1.0) / 10.0);\n    },\n    p_arp_speed: function (v) {\n        return (v === 0) ? 1.0 :\n            ((1.0 - Math.sqrt((v - (v < 100 ? 30 : 32)) / 20000)));\n    },\n    p_duty: function (v) { return (v - 0.5) / -0.5; },\n    p_duty_ramp: function (v) { return v / -0.00005; },\n    p_repeat_speed: function (v) { return v === 0 ? 0 : -(Math.sqrt((v - 32) / 20000) - 1.0); },\n    p_pha_offset: function (v) { return (v < 0 ? -1 : 1) * Math.sqrt(Math.abs(v) / 1020); },\n    p_pha_ramp: function (v) { return (v < 0 ? -1 : 1) * Math.sqrt(Math.abs(v)); },\n    p_lpf_freq: function (v) { return Math.cbrt(v / 0.1); },\n    p_lpf_ramp: function (v) { return (v - 1.0) / 0.0001; },\n    p_lpf_resonance: function (v) { return Math.sqrt((1.0 / (v / 5.0) - 1) / 20); },\n    p_hpf_freq: function (v) { return Math.sqrt(v / 0.1); },\n    p_hpf_ramp: function (v) { return (v - 1.0) / 0.0003; },\n    sound_vol: function (v) { return Math.log(v + 1); ; }\n};\n// convert from internal representation to domain value without units\nvar domain = {\n    p_env_attack: function (v) { return (v / 44100); },\n    p_env_sustain: function (v) { return (v / 44100); },\n    p_env_punch: function (v) { return (v * 100); },\n    p_env_decay: function (v) { return (v / 44100); },\n    p_base_freq: function (v) { return v; },\n    p_freq_limit: function (v) { return v; },\n    p_freq_ramp: function (v) { return (44100 * Math.log(v) / Math.log(0.5)); },\n    p_freq_dramp: function (v) { return (v * 44100 / Math.pow(2, -44101. / 44100)); },\n    p_vib_speed: function (v) { return (441000 / 64. * v); },\n    p_vib_strength: function (v) { return (v * 100); },\n    p_arp_mod: function (v) { return (1. / v); },\n    p_arp_speed: function (v) { return (v / 44100); },\n    p_duty: function (v) { return (100 * v); },\n    p_duty_ramp: function (v) { return (8 * 44100 * v); },\n    p_repeat_speed: function (v) { return v === 0 ? 0 : (44100. / v); },\n    p_pha_offset: function (v) { return (1000 * v / 44100); },\n    p_pha_ramp: function (v) { return (1000 * v); },\n    p_lpf_freq: function (v) { return (v === .1) ? 0 : 8 * 44100 * v / (1 - v); },\n    p_lpf_ramp: function (v) { return Math.pow(v, 44100); },\n    p_lpf_resonance: function (v) { return (100 * (1 - v * .11)); },\n    p_hpf_freq: function (v) { return 8 * 44100 * v / (1 - v); },\n    p_hpf_ramp: function (v) { return Math.pow(v, 44100); },\n    sound_vol: function (v) { return 10 * Math.log(v * v) / Math.log(10); }\n};\nvar domain_inverse = {\n    p_env_attack: function (v) { return (v * 44100); },\n    p_env_sustain: function (v) { return (v * 44100); },\n    p_env_punch: function (v) { return (v / 100); },\n    p_env_decay: function (v) { return (v * 44100); },\n    p_base_freq: function (v) { return v; },\n    p_freq_limit: function (v) { return v; },\n    p_freq_ramp: function (v) { return Math.exp(Math.log(0.5) * v / 44100); },\n    p_freq_dramp: function (v) { return v * Math.pow(2, -44101. / 44100) / 44100; },\n    p_vib_speed: function (v) { return (64. / 441000) * v; },\n    p_vib_strength: function (v) { return (v / 100); },\n    p_arp_mod: function (v) { return (1. / v); },\n    p_arp_speed: function (v) { return (v * 44100); },\n    p_duty: function (v) { return (v / 100); },\n    p_duty_ramp: function (v) { return (v / (8 * 44100)); },\n    p_repeat_speed: function (v) { return v <= 0 ? 0 : v > 1378 ? 32 : (44100 / v); },\n    p_pha_offset: function (v) { return (v / 1000) * 44100; },\n    p_pha_ramp: function (v) { return (v / 1000); },\n    p_lpf_freq: function (v) { return (v / (v + 8 * 44100)); },\n    p_lpf_ramp: function (v) { return Math.pow(v, 1 / 44100); },\n    p_lpf_resonance: function (v) { return (1 - v / 100) / .11; },\n    p_hpf_freq: function (v) { return (v / (v + 8 * 44100)); },\n    p_hpf_ramp: function (v) { return Math.pow(v, 1 / 44100); },\n    sound_vol: function (v) { return Math.sqrt(Math.pow(10, v / 10)); }\n};\n// convert from internal representation to printable units\nvar units = {\n    p_env_attack: function (v) { return (v / 44100).toPrecision(4) + ' sec'; },\n    p_env_sustain: function (v) { return (v / 44100).toPrecision(4) + ' sec'; },\n    p_env_punch: function (v) { return '+' + (v * 100).toPrecision(4) + '%'; },\n    p_env_decay: function (v) { return (v / 44100).toPrecision(4) + ' sec'; },\n    p_base_freq: function (v) { return v.toPrecision(4) + 'Hz'; },\n    p_freq_limit: function (v) { return v.toPrecision(4) + 'Hz'; },\n    p_freq_ramp: function (v) {\n        return (44100 * Math.log(v) / Math.log(0.5)).toPrecision(4) + ' 8va/sec';\n    },\n    p_freq_dramp: function (v) {\n        return (v * 44100 / Math.pow(2, -44101. / 44100)).toExponential(4) +\n            ' 8va/s^2';\n    },\n    p_vib_speed: function (v) {\n        return v === 0 ? 'OFF' :\n            (441000 / 64. * v).toPrecision(4) + ' Hz';\n    },\n    p_vib_strength: function (v) {\n        return v === 0 ? 'OFF' :\n            '&plusmn; ' + (v * 100).toPrecision(4) + '%';\n    },\n    p_arp_mod: function (v) {\n        return ((v === 1) ? 'OFF' :\n            'x ' + (1. / v).toPrecision(4));\n    },\n    p_arp_speed: function (v) {\n        return (v === 0 ? 'OFF' :\n            (v / 44100).toPrecision(4) + ' sec');\n    },\n    p_duty: function (v) { return (100 * v).toPrecision(4) + '%'; },\n    p_duty_ramp: function (v) { return (8 * 44100 * v).toPrecision(4) + '%/sec'; },\n    p_repeat_speed: function (v) {\n        return v === 0 ? 'OFF' :\n            (44100 / v).toPrecision(4) + ' Hz';\n    },\n    p_pha_offset: function (v) {\n        return v === 0 ? 'OFF' :\n            (1000 * v / 44100).toPrecision(4) + ' msec';\n    },\n    // Not so sure about this:\n    p_pha_ramp: function (v) {\n        return v === 0 ? 'OFF' :\n            (1000 * v).toPrecision(4) + ' msec/sec';\n    },\n    p_lpf_freq: function (v) {\n        return (v === .1) ? 'OFF' : Math.round(8 * 44100 * v / (1 - v)) + ' Hz';\n    },\n    p_lpf_ramp: function (v) {\n        if (v === 1)\n            return 'OFF';\n        return Math.pow(v, 44100).toPrecision(4) + ' ^sec';\n    },\n    p_lpf_resonance: function (v) { return (100 * (1 - v * .11)).toPrecision(4) + '%'; },\n    p_hpf_freq: function (v) {\n        return (v === 0) ? 'OFF' : Math.round(8 * 44100 * v / (1 - v)) + ' Hz';\n    },\n    p_hpf_ramp: function (v) {\n        if (v === 1)\n            return 'OFF';\n        return Math.pow(v, 44100).toPrecision(4) + ' ^sec';\n    },\n    sound_vol: function (v) {\n        v = 10 * Math.log(v * v) / Math.log(10);\n        var sign = v >= 0 ? '+' : '';\n        return sign + v.toPrecision(4) + ' dB';\n    }\n};\n// Other exports, to match the previous exports structure.\nexport const convert = {\n    sliders, domain, sliders_inverse, domain_inverse, units,\n};\nexport const parameters = {\n    params_order, params_signed\n};\nexport const waveforms = {\n    SQUARE, SAWTOOTH, SINE, NOISE\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Game } from \"./game/game\";\nasync function init() {\n    await Game.preload();\n    const game = new Game('.canvas');\n    game.start();\n}\nwindow.addEventListener('load', init);\n"],"names":[],"sourceRoot":""}